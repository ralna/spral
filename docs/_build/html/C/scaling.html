

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SCALING - Sparse matrix scalings &mdash; spral v2025-03-03 [C] documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=99edb77c" />

  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=8cb396df"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="SSIDS - Sparse Symmetric Indefinite Direct Solver" href="ssids.html" />
    <link rel="prev" title="RUTHERFORD_BOEING - RB File Utilities" href="rutherford_boeing.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            spral
              <img src="_static/STFC-Logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="csc_format.html">Compressed Sparse Column (CSC) Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="coord_format.html">Coordinate (Coord) Format</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="lsmr.html">LSMR - Sparse Least Squares LSMR Solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_util.html">MATRIX_UTIL - Matrix utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="random.html">RANDOM - Pseudo-random number generator</a></li>
<li class="toctree-l1"><a class="reference internal" href="random_matrix.html">RANDOM_MATRIX - Pseudo-random Matrix Generator</a></li>
<li class="toctree-l1"><a class="reference internal" href="rutherford_boeing.html">RUTHERFORD_BOEING - RB File Utilities</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">SCALING - Sparse matrix scalings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#purpose">Purpose</a></li>
<li class="toctree-l2"><a class="reference internal" href="#auction-algorithm">Auction Algorithm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#routines">Routines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-types">Data-types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#method">Method</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#norm-equilibration-algorithm">Norm-equilibration Algorithm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">Routines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Data-types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equilib-algorithm-method">Method</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hungarian-algorithm">Hungarian Algorithm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id9">Routines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">Data-types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hungarian-algorithm-method">Method</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ssids.html">SSIDS - Sparse Symmetric Indefinite Direct Solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="ssmfe.html">SSMFE - Sparse Symmetric Matrix-Free Eigensolver</a></li>
<li class="toctree-l1"><a class="reference internal" href="ssmfe_expert.html">SSMFE_EXPERT - Sparse Symmetric Matrix-Free Eigensolver (Expert interface)</a></li>
<li class="toctree-l1"><a class="reference internal" href="ssmfe_core.html">SSMFE_CORE - Sparse Symmetric Matrix-Free Eigensolver (Core Algorithm)</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">spral</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">SCALING - Sparse matrix scalings</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/scaling.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="scaling-sparse-matrix-scalings">
<h1>SCALING - Sparse matrix scalings<a class="headerlink" href="#scaling-sparse-matrix-scalings" title="Link to this heading"></a></h1>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;spral_scaling.h&gt;</span><span class="c1"> /* or &lt;spral.h&gt; for all packages */</span>
</pre></div>
</div>
<section id="purpose">
<h2>Purpose<a class="headerlink" href="#purpose" title="Link to this heading"></a></h2>
<p>This package generates various scalings (and matchings) of real sparse matrices.</p>
<p>Given a <strong>symmetric</strong> matrix <span class="math notranslate nohighlight">\(A\)</span>, it finds a diagonal matrix <span class="math notranslate nohighlight">\(D\)</span>
such that the scaled matrix</p>
<div class="math notranslate nohighlight">
\[\hat{A} = DAD\]</div>
<p>has specific numerical properties.</p>
<p>Given an <strong>unsymmetric</strong> or <strong>rectangular</strong> matrix <span class="math notranslate nohighlight">\(A\)</span>, it finds
diagonal matrices <span class="math notranslate nohighlight">\(D_r\)</span> and <span class="math notranslate nohighlight">\(D_c\)</span> such that the scaled matrix</p>
<div class="math notranslate nohighlight">
\[\hat{A} = D_r A D_c\]</div>
<p>has specific numerical properties.</p>
<p>The specific numerical properties delivered depends on the algorithm used:</p>
<dl class="simple">
<dt>Matching-based</dt><dd><p>algorithms scale <span class="math notranslate nohighlight">\(A\)</span> such that the maximum (absolute) value in each row
and column of <span class="math notranslate nohighlight">\(\hat{A}\)</span> is exactly <span class="math notranslate nohighlight">\(1.0\)</span>, where the entries of
maximum value form a maximum cardinality matching. The
<a class="reference internal" href="#hungarian-algorithm"><span class="std std-ref">Hungarian algorithm</span></a> delivers an optimal matching
slowly, whereas the <a class="reference internal" href="#auction-algorithm"><span class="std std-ref">auction algorithm</span></a> delivers an
approximate matching quickly.</p>
</dd>
<dt>Norm-equilibration</dt><dd><p>algorithms scale <span class="math notranslate nohighlight">\(A\)</span> such that the infinity norm of each row and
column of <span class="math notranslate nohighlight">\(\hat{A}\)</span> is <span class="math notranslate nohighlight">\(1.0\pm \tau\)</span> (for some user specified
tolerance <span class="math notranslate nohighlight">\(\tau\)</span>).</p>
</dd>
</dl>
</section>
<section id="auction-algorithm">
<span id="id1"></span><h2>Auction Algorithm<a class="headerlink" href="#auction-algorithm" title="Link to this heading"></a></h2>
<section id="routines">
<h3>Routines<a class="headerlink" href="#routines" title="Link to this heading"></a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_auction_default_options">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_auction_default_options</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_auction_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_auction_default_options" title="Link to this definition"></a><br /></dt>
<dd><p>Intialises members of options structure to default values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>options</strong> – Structure to be initialised.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_auction_sym">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_auction_sym</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">row</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">val</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scaling</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_auction_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_auction_inform</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_auction_sym" title="Link to this definition"></a><br /></dt>
<dd><p>Find a matching-based symmetric scaling using the auction algorithm.</p>
<p>The scaled matrix is such that the entry of maximum absolute value in each
row and column is (approximately) <span class="math notranslate nohighlight">\(1.0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – number of columns in <span class="math notranslate nohighlight">\(A\)</span>.</p></li>
<li><p><strong>ptr[n+1]</strong> – columns pointers for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>row[ptr[n]]</strong> – row indices for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>val[ptr[n]]</strong> – non-zero values for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>scaling[n]</strong> – returns scaling found by routine.</p></li>
<li><p><strong>match</strong> – may be <cite>NULL</cite>; otherwise, an array of size <cite>n</cite> to output the
matching found by routine. Row <cite>i</cite> is matched to column <cite>match[i]</cite>, or is
unmatched if <cite>match[i]=0</cite>.</p></li>
<li><p><strong>options</strong> – controls behaviour of routine.</p></li>
<li><p><strong>inform</strong> – returns information on execution of routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_auction_sym_long">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_auction_sym_long</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">row</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">val</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scaling</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_auction_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_auction_inform</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_auction_sym_long" title="Link to this definition"></a><br /></dt>
<dd><p>As <a class="reference internal" href="#c.spral_scaling_auction_sym" title="spral_scaling_auction_sym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_auction_sym()</span></code></a>, except <cite>ptr</cite> has type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_auction_unsym">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_auction_unsym</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">row</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">val</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rscaling</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cscaling</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_auction_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_auction_inform</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_auction_unsym" title="Link to this definition"></a><br /></dt>
<dd><p>Find a matching-based unsymmetric scaling using the auction algorithm.</p>
<p>The scaled matrix is such that the entry of maximum absolute value in each
row and column is (approximately) <span class="math notranslate nohighlight">\(1.0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> – number of rows in <span class="math notranslate nohighlight">\(A\)</span></p></li>
<li><p><strong>n</strong> – number of columns in <span class="math notranslate nohighlight">\(A\)</span></p></li>
<li><p><strong>ptr[n+1]</strong> – columns pointers for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>)</p></li>
<li><p><strong>row[ptr[n]]</strong> – row indices for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>)</p></li>
<li><p><strong>val[ptr[n]]</strong> – non-zero values for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>)</p></li>
<li><p><strong>rscaling[m]</strong> – returns row scaling found by routine</p></li>
<li><p><strong>cscaling[n]</strong> – returns column scaling found by routine</p></li>
<li><p><strong>match</strong> – may be <cite>NULL</cite>; otherwise, an array of size <cite>m</cite> to output the
matching found by routine. Row <cite>i</cite> is matched to column <cite>match[i]</cite>, or is
unmatched if <cite>match[i]=0</cite>.</p></li>
<li><p><strong>options</strong> – controls behaviour of routine</p></li>
<li><p><strong>inform</strong> – returns information on execution of routine</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_auction_unsym_long">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_auction_unsym_long</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">row</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">val</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rscaling</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cscaling</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_auction_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_auction_inform</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_auction_unsym_long" title="Link to this definition"></a><br /></dt>
<dd><p>As <a class="reference internal" href="#c.spral_scaling_auction_unsym" title="spral_scaling_auction_unsym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_auction_unsym()</span></code></a>, except <cite>ptr</cite> has type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>.</p>
</dd></dl>

</section>
<section id="data-types">
<h3>Data-types<a class="headerlink" href="#data-types" title="Link to this heading"></a></h3>
<dl class="c type">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">struct</span> <span class="pre">spral_scaling_auction_options</span></span></dt>
<dd><p>Used to specify options to the routines <a class="reference internal" href="#c.spral_scaling_auction_sym" title="spral_scaling_auction_sym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_auction_sym()</span></code></a>
and <a class="reference internal" href="#c.spral_scaling_auction_unsym" title="spral_scaling_auction_unsym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_auction_unsym()</span></code></a>. The routine
<a class="reference internal" href="#c.spral_scaling_auction_default_options" title="spral_scaling_auction_default_options"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_auction_default_options()</span></code></a> may be used to intialise
with default values.</p>
<p>Please refer to the <a class="reference internal" href="#auction-algorithm-method"><span class="std std-ref">method section</span></a> for
details on how these parameters are used.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.array_base">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">array_base</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.array_base" title="Link to this definition"></a><br /></dt>
<dd><p>Indexing base for arrays. Either 0 (C indexing) or 1 (Fortran indexing).
Default is 0.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.eps_initial">
<span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eps_initial</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.eps_initial" title="Link to this definition"></a><br /></dt>
<dd><p>Initial value of improvement parameter <span class="math notranslate nohighlight">\(\epsilon\)</span>.
Default is 0.01.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.max_iterations">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">max_iterations</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.max_iterations" title="Link to this definition"></a><br /></dt>
<dd><p>Maximum number of iterations.
Default is 30000.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.max_unchanged">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">max_unchanged</span></span></span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#c.PhonyNameDueToError.max_unchanged" title="Link to this definition"></a><br /></dt>
<dd><p>Together with <cite>min_proportion[]</cite>, specifies termination conditions.
Default is <cite>{10, 100, 100}</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.min_proportion">
<span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">min_proportion</span></span></span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#c.PhonyNameDueToError.min_proportion" title="Link to this definition"></a><br /></dt>
<dd><p>Together with <cite>max_unchanged[]</cite>, specifies termination conditions.
Default is <cite>{0.9, 0.0, 0.0}</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="c type">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">struct</span> <span class="pre">spral_scaling_auction_inform</span></span></dt>
<dd><p>Used to return information about the execution of the algorithm.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.flag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flag</span></span></span><br /></dt>
<dd><p>Gives the exit status of the algorithm (see table below)</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.iterations">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iterations</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.iterations" title="Link to this definition"></a><br /></dt>
<dd><p>Number of iterations performed.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.matched">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">matched</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.matched" title="Link to this definition"></a><br /></dt>
<dd><p>Number of rows and columns that have been matched.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.stat">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">stat</span></span></span><br /></dt>
<dd><p>Fortran stat parameter in the event of an allocation failure (set to 0
otherwise).</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.unmatchable">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unmatchable</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.unmatchable" title="Link to this definition"></a><br /></dt>
<dd><p>Number of columns designated as unmatchable
(there is no way to match it that improves the quality of the matching).</p>
</dd></dl>

<p>Note: As the algorithm may terminate before a full matching is obtained,
<code class="xref c c-member docutils literal notranslate"><span class="pre">spral_scaling_auction_inform.matched</span></code> provides only a lower bound
on the structural rank. However,
<code class="xref c c-member docutils literal notranslate"><span class="pre">spral_scaling_auction_inform.unmatchable</span></code> provides an approximate
lower bound on the structural rank deficiency.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>inform.flag</p></th>
<th class="head"><p>Return status</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Success.</p></td>
</tr>
<tr class="row-odd"><td><p>-1</p></td>
<td><p>Allocation error. Fortran stat value is returned in
<code class="xref c c-member docutils literal notranslate"><span class="pre">spral_scaling_auction_inform.stat</span></code>.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>
<section id="example">
<h3>Example<a class="headerlink" href="#example" title="Link to this heading"></a></h3>
<p>The following code shows an example usage of <code class="xref f f-subr docutils literal notranslate"><span class="pre">auction_scale_sym()</span></code>.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/* examples/C/scaling/auction_sym.c - Example code for SPRAL_SCALING */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spral.h&quot;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="cm">/* Derived types */</span>
<span class="w">   </span><span class="k">struct</span><span class="w"> </span><span class="nc">spral_scaling_auction_options</span><span class="w"> </span><span class="n">options</span><span class="p">;</span>
<span class="w">   </span><span class="k">struct</span><span class="w"> </span><span class="nc">spral_scaling_auction_inform</span><span class="w"> </span><span class="n">inform</span><span class="p">;</span>

<span class="w">   </span><span class="cm">/* Other variables */</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">match</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">scaling</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

<span class="w">   </span><span class="cm">/* Data for symmetric matrix:</span>
<span class="cm">    * ( 2  1         )</span>
<span class="cm">    * ( 1  4  1    8 )</span>
<span class="cm">    * (    1  3  2   )</span>
<span class="cm">    * (       2      )</span>
<span class="cm">    * (    8       2 ) */</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">ptr</span><span class="p">[]</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="mi">2</span><span class="p">,</span><span class="w">             </span><span class="mi">5</span><span class="p">,</span><span class="w">      </span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="w">   </span><span class="mi">8</span><span class="w"> </span><span class="p">};</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">[]</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="mi">2</span><span class="p">,</span><span class="w">   </span><span class="mi">4</span><span class="p">,</span><span class="w">   </span><span class="mi">2</span><span class="p">,</span><span class="w">   </span><span class="mi">3</span><span class="p">,</span><span class="w">   </span><span class="mi">4</span><span class="w">   </span><span class="p">};</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">val</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">8.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="p">};</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Initial matrix:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="n">spral_print_matrix</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">SPRAL_MATRIX_REAL_SYM_INDEF</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">   </span><span class="cm">/* Perform symmetric scaling */</span>
<span class="w">   </span><span class="n">spral_scaling_auction_default_options</span><span class="p">(</span><span class="o">&amp;</span><span class="n">options</span><span class="p">);</span>
<span class="w">   </span><span class="n">spral_scaling_auction_sym</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">scaling</span><span class="p">,</span><span class="w"> </span><span class="n">match</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">options</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">inform</span><span class="p">);</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">inform</span><span class="p">.</span><span class="n">flag</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;spral_scaling_auction_sym() returned with error %5d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">inform</span><span class="p">.</span><span class="n">flag</span><span class="p">);</span>
<span class="w">      </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="cm">/* Print scaling and matching */</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Matching:&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %10d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">match</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Scaling: &quot;</span><span class="p">);</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %10.2le&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">scaling</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">   </span><span class="cm">/* Calculate scaled matrix and print it */</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">         </span><span class="n">val</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scaling</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scaling</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Scaled matrix:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="n">spral_print_matrix</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">SPRAL_MATRIX_REAL_SYM_INDEF</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">   </span><span class="cm">/* Success */</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above code produces the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Initial</span> <span class="n">matrix</span><span class="p">:</span>
<span class="n">Real</span> <span class="n">symmetric</span> <span class="n">indefinite</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">dimension</span> <span class="mi">5</span><span class="n">x5</span> <span class="k">with</span> <span class="mi">8</span> <span class="n">entries</span><span class="o">.</span>
<span class="mi">0</span><span class="p">:</span>   <span class="mf">2.0000E+00</span>   <span class="mf">1.0000E+00</span>
<span class="mi">1</span><span class="p">:</span>   <span class="mf">1.0000E+00</span>   <span class="mf">4.0000E+00</span>   <span class="mf">1.0000E+00</span>                <span class="mf">8.0000E+00</span>
<span class="mi">2</span><span class="p">:</span>                <span class="mf">1.0000E+00</span>   <span class="mf">3.0000E+00</span>   <span class="mf">2.0000E+00</span>
<span class="mi">3</span><span class="p">:</span>                             <span class="mf">2.0000E+00</span>
<span class="mi">4</span><span class="p">:</span>                <span class="mf">8.0000E+00</span>                             <span class="mf">2.0000E+00</span>
<span class="n">Matching</span><span class="p">:</span>          <span class="mi">0</span>         <span class="mi">4</span>         <span class="mi">3</span>         <span class="mi">2</span>         <span class="mi">1</span>
<span class="n">Scaling</span><span class="p">:</span>    <span class="mf">7.07E-01</span>  <span class="mf">1.62E-01</span>  <span class="mf">2.78E-01</span>  <span class="mf">1.80E+00</span>  <span class="mf">7.72E-01</span>
<span class="n">Scaled</span> <span class="n">matrix</span><span class="p">:</span>
<span class="n">Real</span> <span class="n">symmetric</span> <span class="n">indefinite</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">dimension</span> <span class="mi">5</span><span class="n">x5</span> <span class="k">with</span> <span class="mi">8</span> <span class="n">entries</span><span class="o">.</span>
<span class="mi">0</span><span class="p">:</span>   <span class="mf">1.0000E+00</span>   <span class="mf">1.1443E-01</span>
<span class="mi">1</span><span class="p">:</span>   <span class="mf">1.1443E-01</span>   <span class="mf">1.0476E-01</span>   <span class="mf">4.5008E-02</span>                <span class="mf">1.0000E+00</span>
<span class="mi">2</span><span class="p">:</span>                <span class="mf">4.5008E-02</span>   <span class="mf">2.3204E-01</span>   <span class="mf">1.0000E+00</span>
<span class="mi">3</span><span class="p">:</span>                             <span class="mf">1.0000E+00</span>
<span class="mi">4</span><span class="p">:</span>                <span class="mf">1.0000E+00</span>                             <span class="mf">1.1932E+00</span>
</pre></div>
</div>
</section>
<section id="method">
<span id="auction-algorithm-method"></span><h3>Method<a class="headerlink" href="#method" title="Link to this heading"></a></h3>
<p>This algorithm finds a fast approximation to the matching and scaling produced
by the HSL package MC64. If an optimal matching is required, use the
Hungarian algorithm instead. The algorithm works by solving the following
maximum product optimization problem using an auction algorithm. The scaling
is derived from the dual variables associated with the solution.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\max_{\sigma} &amp; \prod_{i=1}^m\prod_{j=1}^n |a_{ij}|\sigma_{ij} &amp; \\
\mathrm{s.t.} &amp; \sum_{i=1}^m\sigma_{ij} = 1, &amp; \forall j=1,n \\
              &amp; \sum_{j=1}^n\sigma_{ij} = 1, &amp; \forall i=1,m \\
              &amp; \sigma_{ij} \in \{0,1\}.\end{split}\]</div>
<p>The array <span class="math notranslate nohighlight">\(\sigma\)</span> gives a matching of rows to columns.</p>
<p>By using the transformation</p>
<div class="math notranslate nohighlight">
\[w_{ij} = \log c_j - \log |a_{ij}|,\]</div>
<p>where <span class="math notranslate nohighlight">\(c_j = \max_i |a_{ij}|\)</span>, the maximum product problem in
<span class="math notranslate nohighlight">\(a_{ij}\)</span> is replaced by a minimum sum problem in <span class="math notranslate nohighlight">\(w_{ij}\)</span> where all
entries are positive. By standard optimization theory, there exist dual
variables <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> corresponding to the constraints that satisfy
the first order optimality conditions</p>
<div class="math notranslate nohighlight">
\[\begin{split}w_{ij} - u_i - v_j = 0, &amp; \mbox{ if } \sigma_{ij }=1, \\
w_{ij} - u_i - v_j \ge 0, &amp; \mbox{ if } \sigma_{ij }=0.\end{split}\]</div>
<p>To obtain a scaling we define scaling matrices <span class="math notranslate nohighlight">\(D_r\)</span> and <span class="math notranslate nohighlight">\(D_c\)</span> as</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}d^r_i = e^{u_i},\\d^c_i = e^{v_i}.\end{aligned}\end{align} \]</div>
<p>If a symmetric scaling is required, we average these as</p>
<div class="math notranslate nohighlight">
\[d_i = \sqrt{d^r_id^c_i}.\]</div>
<p>By the first order optimality conditions, these scaling matrices guarantee that</p>
<div class="math notranslate nohighlight">
\[\begin{split}d^r_i|a_{ij}|d^c_j = 1, &amp;&amp; \mbox{if } \sigma_{ij}=1, \\
d^r_i|a_{ij}|d^c_j \le 1, &amp;&amp; \mbox{if } \sigma_{ij}=0.\end{split}\]</div>
<p>To solve the minimum sum problem an auction algorithm is used. The
algorithm is <strong>not</strong> guaranteed to find an optimal matching. However it
can find an approximate matching very quickly. A matching is maintained along
with the row pricing vector <span class="math notranslate nohighlight">\(u\)</span>. In each major iteration, we loop over
each column in turn. If the column <span class="math notranslate nohighlight">\(j\)</span> is unmatched, we calculate the
value <span class="math notranslate nohighlight">\(p_i = w_{ij} - u_i\)</span> for each entry and find the maximum across the
column. If this maximum is positive, the current matching can be improved by
matching column <span class="math notranslate nohighlight">\(j\)</span> with row <span class="math notranslate nohighlight">\(i\)</span>. This may mean that the previous
match of row <span class="math notranslate nohighlight">\(i\)</span> now becomes unmatched. We update the price of row
<span class="math notranslate nohighlight">\(i\)</span>, that is <span class="math notranslate nohighlight">\(u_i\)</span>, to reflect this new benefit and continue to the
next column.</p>
<p>To prevent incremental shuffling, we insist that the value of adding a new
column is at least a threshold value <span class="math notranslate nohighlight">\(\epsilon\)</span> above zero, where
<span class="math notranslate nohighlight">\(\epsilon\)</span> is based on the last iteration in which row <span class="math notranslate nohighlight">\(i\)</span> changed
its match. This is done by adding <span class="math notranslate nohighlight">\(\epsilon\)</span> to the price <span class="math notranslate nohighlight">\(u_i\)</span>,
where <span class="math notranslate nohighlight">\(\epsilon = \mathrm{options.eps_initial} + \mathrm{itr} / (n+1)\)</span>,
where itr is the current iteration number.</p>
<p>The algorithm terminates if any of the following are satsified:</p>
<ul class="simple">
<li><p>All entries are matched.</p></li>
<li><p>The number of major iterations exceeds
<code class="xref c c-member docutils literal notranslate"><span class="pre">options.max_iterations</span></code>.</p></li>
<li><p>At least <code class="xref c c-member docutils literal notranslate"><span class="pre">options.max_unchanged[0]</span></code>
iterations have passed without the cardinality of the matching increasing,
and the proportion of matched columns is
<code class="xref c c-member docutils literal notranslate"><span class="pre">options.min_proportion[0]</span></code>.</p></li>
<li><p>At least <code class="xref c c-member docutils literal notranslate"><span class="pre">options.max_unchanged[1]</span></code>
iterations have passed without the cardinality of the matching increasing,
and the proportion of matched columns is
<code class="xref c c-member docutils literal notranslate"><span class="pre">options.min_proportion[1]</span></code>.</p></li>
<li><p>At least <code class="xref c c-member docutils literal notranslate"><span class="pre">options.max_unchanged[2]</span></code>
iterations have passed without the cardinality of the matching increasing,
and the proportion of matched columns is
<code class="xref c c-member docutils literal notranslate"><span class="pre">options.min_proportion[2]</span></code>.</p></li>
</ul>
<p>The different combinations given by options.max_unchanged[] and
options.min_proportion[] allow a wide range of termination
heuristics to be specified by the user depending on their particular needs.
Note that the matching and scaling produced will always be approximate as
<span class="math notranslate nohighlight">\(\epsilon\)</span> is non-zero.</p>
<p>Further details are given in the following paper:</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>J.D. Hogg and J.A. Scott. (2014). On the efficient scaling of sparse symmetric matrices using an auction algorithm. RAL Technical Report RAL-P-2014-002. [<a class="reference external" href="https://epubs.stfc.ac.uk/work/11539865">STFC TR</a>]</p>
</aside>
</aside>
</section>
</section>
<section id="norm-equilibration-algorithm">
<h2>Norm-equilibration Algorithm<a class="headerlink" href="#norm-equilibration-algorithm" title="Link to this heading"></a></h2>
<section id="id3">
<h3>Routines<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_equilib_default_options">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_equilib_default_options</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_equilib_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_equilib_default_options" title="Link to this definition"></a><br /></dt>
<dd><p>Intialises members of options structure to default values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>options</strong> – Structure to be initialised.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_equilib_sym">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_equilib_sym</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">row</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">val</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scaling</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_equilib_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_equilib_inform</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_equilib_sym" title="Link to this definition"></a><br /></dt>
<dd><p>Find a symmetric scaling using the norm-equilibration
algorithm.</p>
<p>The scaled matrix is such that the infinity norm of each row and column are
equal to <span class="math notranslate nohighlight">\(1.0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – number of columns in <span class="math notranslate nohighlight">\(A\)</span>.</p></li>
<li><p><strong>ptr[n]</strong> – columns pointers for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>row[ptr[n]]</strong> – row indices for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>val[ptr[n]]</strong> – non-zero values for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>scaling[n]</strong> – returns scaling found by routine.</p></li>
<li><p><strong>options</strong> – controls behaviour of routine.</p></li>
<li><p><strong>inform</strong> – returns information on execution of routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_equilib_sym_long">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_equilib_sym_long</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">row</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">val</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scaling</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_equilib_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_equilib_inform</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_equilib_sym_long" title="Link to this definition"></a><br /></dt>
<dd><p>As <a class="reference internal" href="#c.spral_scaling_equilib_sym" title="spral_scaling_equilib_sym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_equilib_sym()</span></code></a>, except <cite>ptr</cite> has type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_equilib_unsym">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_equilib_unsym</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">row</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">val</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rscaling</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cscaling</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_equilib_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_equilib_inform</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_equilib_unsym" title="Link to this definition"></a><br /></dt>
<dd><p>Find an unsymmetric scaling using the norm-equilibration
algorithm.</p>
<p>The scaled matrix is such that the infinity norm of each row and column are
equal to <span class="math notranslate nohighlight">\(1.0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> – number of rows in <span class="math notranslate nohighlight">\(A\)</span>.</p></li>
<li><p><strong>n</strong> – number of columns in <span class="math notranslate nohighlight">\(A\)</span>.</p></li>
<li><p><strong>ptr[n+1]</strong> – columns pointers for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>row[ptr[n]]</strong> – row indices for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>val[ptr[n]]</strong> – non-zero values for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>rscaling[m]</strong> – returns row scaling found by routine.</p></li>
<li><p><strong>cscaling[n]</strong> – returns column scaling found by routine.</p></li>
<li><p><strong>options</strong> – controls behaviour of routine.</p></li>
<li><p><strong>inform</strong> – returns information on execution of routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_equilib_unsym_long">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_equilib_unsym_long</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">row</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">val</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rscaling</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cscaling</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_equilib_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_equilib_inform</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_equilib_unsym_long" title="Link to this definition"></a><br /></dt>
<dd><p>As <a class="reference internal" href="#c.spral_scaling_equilib_unsym" title="spral_scaling_equilib_unsym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_equilib_unsym()</span></code></a>, except <cite>ptr</cite> has type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>.</p>
</dd></dl>

</section>
<section id="id4">
<h3>Data-types<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<dl class="c type">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">struct</span> <span class="pre">spral_scaling_equilib_options</span></span></dt>
<dd><p>Used to specify options to the routines <a class="reference internal" href="#c.spral_scaling_equilib_sym" title="spral_scaling_equilib_sym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_equilib_sym()</span></code></a>
and <a class="reference internal" href="#c.spral_scaling_equilib_unsym" title="spral_scaling_equilib_unsym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_equilib_unsym()</span></code></a>. The routine
<a class="reference internal" href="#c.spral_scaling_equilib_default_options" title="spral_scaling_equilib_default_options"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_equilib_default_options()</span></code></a> may be used to intialise
with default values.</p>
<p>Please refer to the <a class="reference internal" href="#equilib-algorithm-method"><span class="std std-ref">method section</span></a> for
details on how these parameters are used.</p>
<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">array_base</span></span></span><br /></dt>
<dd><p>Indexing base for arrays. Either 0 (C indexing) or 1 (Fortran indexing).
Default is 0.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">max_iterations</span></span></span><br /></dt>
<dd><p>Maximum number of iterations.
Default is 10.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.tol">
<span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tol</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.tol" title="Link to this definition"></a><br /></dt>
<dd><p>Convergence tolerance <span class="math notranslate nohighlight">\(\tau\)</span>.
Default is 1e-8.</p>
</dd></dl>

</dd></dl>

<dl class="c type">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">struct</span> <span class="pre">spral_scaling_equilib_inform</span></span></dt>
<dd><p>Used to return information about the execution of the algorithm.</p>
<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flag</span></span></span><br /></dt>
<dd><p>Gives the exit status of the algorithm (see table below).</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iterations</span></span></span><br /></dt>
<dd><p>Number of iteration performed.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">stat</span></span></span><br /></dt>
<dd><p>Holds the Fortran stat parameter in the event of an
allocation failure (set to 0 otherwise).</p>
</dd></dl>

<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>inform.flag</p></th>
<th class="head"><p>Return status</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Success.</p></td>
</tr>
<tr class="row-odd"><td><p>-1</p></td>
<td><p>Allocation error. Fortran stat value is returned in
<code class="xref c c-member docutils literal notranslate"><span class="pre">inform.stat</span></code>.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>
<section id="id5">
<h3>Example<a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<p>The following code shows an example usage of
<a class="reference internal" href="#c.spral_scaling_equilib_sym" title="spral_scaling_equilib_sym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_equilib_sym()</span></code></a>.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/* examples/C/scaling/equilib_sym.c - Example code for SPRAL_SCALING */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spral.h&quot;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="cm">/* Derived types */</span>
<span class="w">   </span><span class="k">struct</span><span class="w"> </span><span class="nc">spral_scaling_equilib_options</span><span class="w"> </span><span class="n">options</span><span class="p">;</span>
<span class="w">   </span><span class="k">struct</span><span class="w"> </span><span class="nc">spral_scaling_equilib_inform</span><span class="w"> </span><span class="n">inform</span><span class="p">;</span>

<span class="w">   </span><span class="cm">/* Other variables */</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">scaling</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

<span class="w">   </span><span class="cm">/* Data for symmetric matrix:</span>
<span class="cm">    * ( 2  1         )</span>
<span class="cm">    * ( 1  4  1    8 )</span>
<span class="cm">    * (    1  3  2   )</span>
<span class="cm">    * (       2      )</span>
<span class="cm">    * (    8       2 ) */</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">ptr</span><span class="p">[]</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="mi">2</span><span class="p">,</span><span class="w">             </span><span class="mi">5</span><span class="p">,</span><span class="w">      </span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="w">   </span><span class="mi">8</span><span class="w"> </span><span class="p">};</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">[]</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="mi">2</span><span class="p">,</span><span class="w">   </span><span class="mi">4</span><span class="p">,</span><span class="w">   </span><span class="mi">2</span><span class="p">,</span><span class="w">   </span><span class="mi">3</span><span class="p">,</span><span class="w">   </span><span class="mi">4</span><span class="w">   </span><span class="p">};</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">val</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">8.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="p">};</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Initial matrix:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="n">spral_print_matrix</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">SPRAL_MATRIX_REAL_SYM_INDEF</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">   </span><span class="cm">/* Perform symmetric scaling */</span>
<span class="w">   </span><span class="n">spral_scaling_equilib_default_options</span><span class="p">(</span><span class="o">&amp;</span><span class="n">options</span><span class="p">);</span>
<span class="w">   </span><span class="n">spral_scaling_equilib_sym</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">scaling</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">options</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">inform</span><span class="p">);</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">inform</span><span class="p">.</span><span class="n">flag</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;spral_scaling_equilib_sym() returned with error %5d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">inform</span><span class="p">.</span><span class="n">flag</span><span class="p">);</span>
<span class="w">      </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="cm">/* Print scaling */</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Scaling: &quot;</span><span class="p">);</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %10.2le&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">scaling</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">   </span><span class="cm">/* Calculate scaled matrix and print it */</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">         </span><span class="n">val</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scaling</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scaling</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Scaled matrix:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="n">spral_print_matrix</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">SPRAL_MATRIX_REAL_SYM_INDEF</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">   </span><span class="cm">/* Success */</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above code produces the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Initial</span> <span class="n">matrix</span><span class="p">:</span>
<span class="n">Real</span> <span class="n">symmetric</span> <span class="n">indefinite</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">dimension</span> <span class="mi">5</span><span class="n">x5</span> <span class="k">with</span> <span class="mi">8</span> <span class="n">entries</span><span class="o">.</span>
<span class="mi">0</span><span class="p">:</span>   <span class="mf">2.0000E+00</span>   <span class="mf">1.0000E+00</span>
<span class="mi">1</span><span class="p">:</span>   <span class="mf">1.0000E+00</span>   <span class="mf">4.0000E+00</span>   <span class="mf">1.0000E+00</span>                <span class="mf">8.0000E+00</span>
<span class="mi">2</span><span class="p">:</span>                <span class="mf">1.0000E+00</span>   <span class="mf">3.0000E+00</span>   <span class="mf">2.0000E+00</span>
<span class="mi">3</span><span class="p">:</span>                             <span class="mf">2.0000E+00</span>
<span class="mi">4</span><span class="p">:</span>                <span class="mf">8.0000E+00</span>                             <span class="mf">2.0000E+00</span>
<span class="n">Scaling</span><span class="p">:</span>    <span class="mf">7.07e-01</span>   <span class="mf">3.54e-01</span>   <span class="mf">5.77e-01</span>   <span class="mf">8.66e-01</span>   <span class="mf">3.54e-01</span>
<span class="n">Scaled</span> <span class="n">matrix</span><span class="p">:</span>
<span class="n">Real</span> <span class="n">symmetric</span> <span class="n">indefinite</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">dimension</span> <span class="mi">5</span><span class="n">x5</span> <span class="k">with</span> <span class="mi">8</span> <span class="n">entries</span><span class="o">.</span>
<span class="mi">0</span><span class="p">:</span>   <span class="mf">1.0000E+00</span>   <span class="mf">2.5000E-01</span>
<span class="mi">1</span><span class="p">:</span>   <span class="mf">2.5000E-01</span>   <span class="mf">5.0000E-01</span>   <span class="mf">2.0412E-01</span>                <span class="mf">1.0000E+00</span>
<span class="mi">2</span><span class="p">:</span>                <span class="mf">2.0412E-01</span>   <span class="mf">1.0000E+00</span>   <span class="mf">9.9960E-01</span>
<span class="mi">3</span><span class="p">:</span>                             <span class="mf">9.9960E-01</span>
<span class="mi">4</span><span class="p">:</span>                <span class="mf">1.0000E+00</span>                             <span class="mf">2.5000E-01</span>
</pre></div>
</div>
</section>
<section id="equilib-algorithm-method">
<span id="id6"></span><h3>Method<a class="headerlink" href="#equilib-algorithm-method" title="Link to this heading"></a></h3>
<p>This algorithm is very similar to that used by the HSL routine MC77.
An iterative method is used to scale the infinity norm of both rows and columns
to <span class="math notranslate nohighlight">\(1.0\)</span> with an asymptotic linear rate of convergence of
<span class="math notranslate nohighlight">\(\frac{1}{2}\)</span>, preserving symmetry if the matrix is symmetric.</p>
<p>For unsymmetric matrices, the algorithm outline is as follows:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(D_r^{(0)} = I, D_c^{(0)}=I\)</span></p></li>
<li><p><strong>for</strong> (<span class="math notranslate nohighlight">\(k=1,\)</span> options.max_iterations)</p>
<blockquote>
<div><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A^{(k-1)} = D_r^{(k-1)} A D_c^{(k-1)}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((D_r^{(k)})_{ii} = (D_r^{(k-1)})_{ii}\; /\; \sqrt{\max_j(A^{(k-1)})_{ij}}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((D_c^{(k)})_{jj} = (D_c^{(k-1)})_{jj}\; /\; \sqrt{\max_i(A^{(k-1)})_{ij}}\)</span></p></li>
<li><p><strong>if</strong> ( <span class="math notranslate nohighlight">\(|1-\|A^{(k-1)}\|_{\max}|\le\)</span> options.tol ) <strong>exit</strong></p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>For symmetric matrices, <span class="math notranslate nohighlight">\(A^{(k-1)}\)</span> is symmetric, so <span class="math notranslate nohighlight">\(D_r^{(k)} = D_c^{(k)}\)</span>, and some operations can be skipped.</p>
<p>Further details are given in the following paper:</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="16">
<li><p>Knight, D. Ruiz and B. Ucar. (2012). A symmetry preserving algorithm for matrix scaling. INRIA Research Report 7552. [<a class="reference external" href="https://hal.inria.fr/inria-00569250v3/document">INRIA TR</a>]</p></li>
</ol>
</aside>
</aside>
</section>
</section>
<section id="hungarian-algorithm">
<span id="id8"></span><h2>Hungarian Algorithm<a class="headerlink" href="#hungarian-algorithm" title="Link to this heading"></a></h2>
<section id="id9">
<h3>Routines<a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_hungarian_default_options">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_hungarian_default_options</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_hungarian_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_hungarian_default_options" title="Link to this definition"></a><br /></dt>
<dd><p>Intialises members of options structure to default values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>options</strong> – Structure to be initialised.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_hungarian_sym">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_hungarian_sym</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">row</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">val</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scaling</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_hungarian_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_hungarian_inform</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_hungarian_sym" title="Link to this definition"></a><br /></dt>
<dd><p>Find a matching-based symmetric scaling using the Hungarian algorithm.</p>
<p>The scaled matrix is such that the entry of maximum absolute value in each
row and column is <span class="math notranslate nohighlight">\(1.0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – number of columns in <span class="math notranslate nohighlight">\(A\)</span>.</p></li>
<li><p><strong>ptr[n+1]</strong> – columns pointers for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>row[ptr[n]]</strong> – row indices for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>val[ptr[n]]</strong> – non-zero values for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>scaling[n]</strong> – returns scaling found by routine.</p></li>
<li><p><strong>match</strong> – may be <cite>NULL</cite>; otherwise, an array of size <cite>n</cite> to output the
matching found by routine. Row <cite>i</cite> is matched to column <cite>match[i]</cite>, or is
unmatched if <cite>match[i]=0</cite>.</p></li>
<li><p><strong>options</strong> – controls behaviour of routine.</p></li>
<li><p><strong>inform</strong> – returns information on execution of routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_hungarian_sym_long">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_hungarian_sym_long</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">row</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">val</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scaling</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_hungarian_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_hungarian_inform</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_hungarian_sym_long" title="Link to this definition"></a><br /></dt>
<dd><p>As <a class="reference internal" href="#c.spral_scaling_hungarian_sym" title="spral_scaling_hungarian_sym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_hungarian_sym()</span></code></a>, except <cite>ptr</cite> has type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_hungarian_unsym">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_hungarian_unsym</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">row</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">val</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rscaling</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cscaling</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_hungarian_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_hungarian_inform</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_hungarian_unsym" title="Link to this definition"></a><br /></dt>
<dd><p>Find a matching-based symmetric scaling using the Hungarian algorithm.</p>
<p>The scaled matrix is such that the entry of maximum absolute value in each
row and column is <span class="math notranslate nohighlight">\(1.0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> – number of rows in <span class="math notranslate nohighlight">\(A\)</span>.</p></li>
<li><p><strong>n</strong> – number of columns in <span class="math notranslate nohighlight">\(A\)</span>.</p></li>
<li><p><strong>ptr[n+1]</strong> – columns pointers for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>row[ptr[n]]</strong> – row indices for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>val[ptr[n]]</strong> – non-zero values for <span class="math notranslate nohighlight">\(A\)</span> (see <a class="reference internal" href="csc_format.html"><span class="doc">CSC format</span></a>).</p></li>
<li><p><strong>rscaling[m]</strong> – returns row scaling found by routine.</p></li>
<li><p><strong>cscaling[n]</strong> – returns column scaling found by routine.</p></li>
<li><p><strong>match</strong> – may be <cite>NULL</cite>; otherwise, an array of size <cite>n</cite> to output the
matching found by routine. Row <cite>i</cite> is matched to column <cite>match[i]</cite>, or is
unmatched if <cite>match[i]=0</cite>.</p></li>
<li><p><strong>options</strong> – controls behaviour of routine.</p></li>
<li><p><strong>inform</strong> – returns information on execution of routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_scaling_hungarian_unsym_long">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_scaling_hungarian_unsym_long</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">row</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">val</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rscaling</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cscaling</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_hungarian_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_scaling_hungarian_inform</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_scaling_hungarian_unsym_long" title="Link to this definition"></a><br /></dt>
<dd><p>As <a class="reference internal" href="#c.spral_scaling_hungarian_unsym" title="spral_scaling_hungarian_unsym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_hungarian_unsym()</span></code></a>, except <cite>ptr</cite> has type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>.</p>
</dd></dl>

</section>
<section id="id10">
<h3>Data-types<a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<dl class="c type">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">struct</span> <span class="pre">spral_scaling_hungarian_options</span></span></dt>
<dd><p>Used to specify options to the routines <a class="reference internal" href="#c.spral_scaling_hungarian_sym" title="spral_scaling_hungarian_sym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_hungarian_sym()</span></code></a>
and <a class="reference internal" href="#c.spral_scaling_hungarian_unsym" title="spral_scaling_hungarian_unsym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_hungarian_unsym()</span></code></a>. The routine
<a class="reference internal" href="#c.spral_scaling_hungarian_default_options" title="spral_scaling_hungarian_default_options"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_hungarian_default_options()</span></code></a> may be used to intialise
with default values.</p>
<p>Please refer to the <a class="reference internal" href="#hungarian-algorithm-method"><span class="std std-ref">method section</span></a> for
details on how these parameters are used.</p>
<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">array_base</span></span></span><br /></dt>
<dd><p>Indexing base for arrays. Either 0 (C indexing) or 1 (Fortran indexing).
Default is 0.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.scale_if_singular">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scale_if_singular</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.scale_if_singular" title="Link to this definition"></a><br /></dt>
<dd><p>Behaviour for structurally singular matrices. If <cite>true</cite>, a partial scaling
corresponding to a maximum cardinality matching will be returned.
If <cite>false</cite>, an identity scaling is returned with an error code.
Default is <cite>false</cite>.</p>
</dd></dl>

<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If <cite>options.scale_if_singular=true</cite>, the resulting scaling will
only be maximal for the matched rows/columns, and extreme care should be
taken to ensure its use is meaningful!</p>
</div>
</dd></dl>

<dl>
<dt class="sig sig-object f" id="f/_/hungarian_inform">
<em class="property"><span class="pre">type</span>&#160; </em><span class="sig-name descname"><span class="pre">hungarian_inform</span></span><a class="headerlink" href="#f/_/hungarian_inform" title="Link to this definition"></a></dt>
<dd><p>Used to return information about the execution of the algorithm.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.flag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flag</span></span></span><a class="headerlink" href="#c.flag" title="Link to this definition"></a><br /></dt>
<dd><p>Exit status of the algorithm (see table below)</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.matched">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">matched</span></span></span><a class="headerlink" href="#c.matched" title="Link to this definition"></a><br /></dt>
<dd><p>Number of rows and columns that have been matched.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.stat">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">stat</span></span></span><a class="headerlink" href="#c.stat" title="Link to this definition"></a><br /></dt>
<dd><p>Holds the Fortran stat parameter in the event of an allocation failure
(set to 0 otherwise).</p>
</dd></dl>

<p><strong>Note:</strong> The number matched gives the structural rank of the matrix.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>inform.flag</p></th>
<th class="head"><p>Return status</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Success.</p></td>
</tr>
<tr class="row-odd"><td><p>+1</p></td>
<td><p>Warning: Matrix is structurally rank-deficient.
Only returned if <cite>options.scale_if_singular=true</cite>.</p></td>
</tr>
<tr class="row-even"><td><p>-1</p></td>
<td><p>Error: Allocation failed.
Fortran stat value is returned in <cite>inform.stat</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p>-2</p></td>
<td><p>Error: Matrix is structurally rank-deficient.
Only returned if <cite>options.scale_if_singular=false</cite>. Scaling
vector(s) will be set to the identity, and a maximum
cardinality matching will be returned in <cite>match[]</cite> (if
present).</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>
<section id="id11">
<h3>Example<a class="headerlink" href="#id11" title="Link to this heading"></a></h3>
<p>The following code shows an example usage of
<a class="reference internal" href="#c.spral_scaling_hungarian_sym" title="spral_scaling_hungarian_sym"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_scaling_hungarian_sym()</span></code></a>.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/* examples/C/scaling/hungarian_sym.c - Example code for SPRAL_SCALING */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spral.h&quot;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="cm">/* Derived types */</span>
<span class="w">   </span><span class="k">struct</span><span class="w"> </span><span class="nc">spral_scaling_hungarian_options</span><span class="w"> </span><span class="n">options</span><span class="p">;</span>
<span class="w">   </span><span class="k">struct</span><span class="w"> </span><span class="nc">spral_scaling_hungarian_inform</span><span class="w"> </span><span class="n">inform</span><span class="p">;</span>

<span class="w">   </span><span class="cm">/* Other variables */</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">match</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">scaling</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

<span class="w">   </span><span class="cm">/* Data for symmetric matrix:</span>
<span class="cm">    * ( 2  1         )</span>
<span class="cm">    * ( 1  4  1    8 )</span>
<span class="cm">    * (    1  3  2   )</span>
<span class="cm">    * (       2      )</span>
<span class="cm">    * (    8       2 ) */</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">ptr</span><span class="p">[]</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="mi">2</span><span class="p">,</span><span class="w">             </span><span class="mi">5</span><span class="p">,</span><span class="w">      </span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="w">   </span><span class="mi">8</span><span class="w"> </span><span class="p">};</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">[]</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="mi">2</span><span class="p">,</span><span class="w">   </span><span class="mi">4</span><span class="p">,</span><span class="w">   </span><span class="mi">2</span><span class="p">,</span><span class="w">   </span><span class="mi">3</span><span class="p">,</span><span class="w">   </span><span class="mi">4</span><span class="w">   </span><span class="p">};</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">val</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">8.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="p">};</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Initial matrix:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="n">spral_print_matrix</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">SPRAL_MATRIX_REAL_SYM_INDEF</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">   </span><span class="cm">/* Perform symmetric scaling */</span>
<span class="w">   </span><span class="n">spral_scaling_hungarian_default_options</span><span class="p">(</span><span class="o">&amp;</span><span class="n">options</span><span class="p">);</span>
<span class="w">   </span><span class="n">spral_scaling_hungarian_sym</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">scaling</span><span class="p">,</span><span class="w"> </span><span class="n">match</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">options</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">inform</span><span class="p">);</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">inform</span><span class="p">.</span><span class="n">flag</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;spral_scaling_hungarian_sym() returned with error %5d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">inform</span><span class="p">.</span><span class="n">flag</span><span class="p">);</span>
<span class="w">      </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="cm">/* Print scaling and matching */</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Matching:&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %10d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">match</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Scaling: &quot;</span><span class="p">);</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %10.2le&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">scaling</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">   </span><span class="cm">/* Calculate scaled matrix and print it */</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">         </span><span class="n">val</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scaling</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scaling</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Scaled matrix:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="n">spral_print_matrix</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">SPRAL_MATRIX_REAL_SYM_INDEF</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">   </span><span class="cm">/* Success */</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above code produces the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Initial</span> <span class="n">matrix</span><span class="p">:</span>
<span class="n">Real</span> <span class="n">symmetric</span> <span class="n">indefinite</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">dimension</span> <span class="mi">5</span><span class="n">x5</span> <span class="k">with</span> <span class="mi">8</span> <span class="n">entries</span><span class="o">.</span>
<span class="mi">0</span><span class="p">:</span>   <span class="mf">2.0000E+00</span>   <span class="mf">1.0000E+00</span>
<span class="mi">1</span><span class="p">:</span>   <span class="mf">1.0000E+00</span>   <span class="mf">4.0000E+00</span>   <span class="mf">1.0000E+00</span>                <span class="mf">8.0000E+00</span>
<span class="mi">2</span><span class="p">:</span>                <span class="mf">1.0000E+00</span>   <span class="mf">3.0000E+00</span>   <span class="mf">2.0000E+00</span>
<span class="mi">3</span><span class="p">:</span>                             <span class="mf">2.0000E+00</span>
<span class="mi">4</span><span class="p">:</span>                <span class="mf">8.0000E+00</span>                             <span class="mf">2.0000E+00</span>
<span class="n">Matching</span><span class="p">:</span>          <span class="mi">0</span>          <span class="mi">4</span>          <span class="mi">3</span>          <span class="mi">2</span>          <span class="mi">1</span>
<span class="n">Scaling</span><span class="p">:</span>    <span class="mf">7.07e-01</span>   <span class="mf">3.54e-01</span>   <span class="mf">5.77e-01</span>   <span class="mf">8.66e-01</span>   <span class="mf">3.54e-01</span>
<span class="n">Scaled</span> <span class="n">matrix</span><span class="p">:</span>
<span class="n">Real</span> <span class="n">symmetric</span> <span class="n">indefinite</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">dimension</span> <span class="mi">5</span><span class="n">x5</span> <span class="k">with</span> <span class="mi">8</span> <span class="n">entries</span><span class="o">.</span>
<span class="mi">0</span><span class="p">:</span>   <span class="mf">1.0000E+00</span>   <span class="mf">2.5000E-01</span>
<span class="mi">1</span><span class="p">:</span>   <span class="mf">2.5000E-01</span>   <span class="mf">5.0000E-01</span>   <span class="mf">2.0412E-01</span>                <span class="mf">1.0000E+00</span>
<span class="mi">2</span><span class="p">:</span>                <span class="mf">2.0412E-01</span>   <span class="mf">1.0000E+00</span>   <span class="mf">1.0000E+00</span>
<span class="mi">3</span><span class="p">:</span>                             <span class="mf">1.0000E+00</span>
<span class="mi">4</span><span class="p">:</span>                <span class="mf">1.0000E+00</span>                             <span class="mf">2.5000E-01</span>
</pre></div>
</div>
</section>
<section id="hungarian-algorithm-method">
<span id="id12"></span><h3>Method<a class="headerlink" href="#hungarian-algorithm-method" title="Link to this heading"></a></h3>
<p>This algorithm is the same as used by the HSL package MC64. A scaling
is derived from dual variables found during the solution of the below
maximum product optimization problem using the Hungarian algorithm.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\max_{\sigma} &amp; \prod_{i=1}^m\prod_{j=1}^n |a_{ij}|\sigma_{ij} &amp; \\
\mathrm{s.t.} &amp; \sum_{i=1}^m\sigma_{ij} = 1, &amp; \forall j=1,n \\
              &amp; \sum_{j=1}^n\sigma_{ij} = 1, &amp; \forall i=1,m \\
              &amp; \sigma_{ij} \in \{0,1\}.\end{split}\]</div>
<p>The array <span class="math notranslate nohighlight">\(\sigma\)</span> gives a matching of rows to columns.</p>
<p>By using the transformation</p>
<div class="math notranslate nohighlight">
\[w_{ij} = \log c_j - \log |a_{ij}|,\]</div>
<p>where <span class="math notranslate nohighlight">\(c_j = \max_i |a_{ij}|\)</span>, the maximum product problem in
<span class="math notranslate nohighlight">\(a_{ij}\)</span> is replaced by a minimum sum problem in <span class="math notranslate nohighlight">\(w_{ij}\)</span> where all
entries are positive. By standard optimization theory, there exist dual
variables <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> corresponding to the constraints that satisfy
the first order optimality conditions</p>
<div class="math notranslate nohighlight">
\[\begin{split}w_{ij} - u_i - v_j = 0, &amp; \mbox{if } \sigma_{ij }=1, \\
w_{ij} - u_i - v_j \ge 0, &amp; \mbox{if } \sigma_{ij }=0.\end{split}\]</div>
<p>To obtain a scaling we define scaling matrices <span class="math notranslate nohighlight">\(D_r\)</span> and <span class="math notranslate nohighlight">\(D_c\)</span> as</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}d^r_i = e^{u_i},\\d^c_i = e^{v_i}.\end{aligned}\end{align} \]</div>
<p>If a symmetric scaling is required, we average these as</p>
<div class="math notranslate nohighlight">
\[d_i = \sqrt{d^r_id^c_i}.\]</div>
<p>By the first order optimality conditions, these scaling matrices guarantee that</p>
<div class="math notranslate nohighlight">
\[\begin{split}d^r_i|a_{ij}|d^c_j = 1, &amp;&amp; \mbox{if } \sigma_{ij}=1, \\
d^r_i|a_{ij}|d^c_j \le 1, &amp;&amp; \mbox{if } \sigma_{ij}=0.\end{split}\]</div>
<p>To solve the minimum sum problem, the Hungarian algorithm maintains an optimal
matching on a subset of the rows and columns. It proceeds to grow this set by
finding augmenting paths from an unmatched row to an unmatched column. The
algorithm is guaranteed to find the optimal solution in a fixed number of steps,
but can be very slow as it may need to explore the full matrix a number of
times equal to the dimension of the matrix. To minimize the solution time, a
warmstarting heuristic is used to construct an initial optimal subset matching.</p>
<p>Further details are given in the following paper:</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id13" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>I.S. Duff and J. Koster. (1997). The design and use of algorithms for permuting large entries to the diagonal of sparse matrices. SIAM J. Matrix Anal. Applics. 20(4), pp 889–901. [<a class="reference external" href="http://dx.doi.org/10.1137/S0895479897317661">Journal</a>] [<a class="reference external" href="https://epubs.stfc.ac.uk/work/33194">Preprint</a>]</p>
</aside>
</aside>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="rutherford_boeing.html" class="btn btn-neutral float-left" title="RUTHERFORD_BOEING - RB File Utilities" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ssids.html" class="btn btn-neutral float-right" title="SSIDS - Sparse Symmetric Indefinite Direct Solver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Computational Mathematics Group, STFC Rutherford Appleton Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>