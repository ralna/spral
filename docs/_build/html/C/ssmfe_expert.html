

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SSMFE_EXPERT - Sparse Symmetric Matrix-Free Eigensolver (Expert interface) &mdash; spral v2025-05-20 [C] documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=99edb77c" />

  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=647c0742"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="SSMFE_CORE - Sparse Symmetric Matrix-Free Eigensolver (Core Algorithm)" href="ssmfe_core.html" />
    <link rel="prev" title="SSMFE - Sparse Symmetric Matrix-Free Eigensolver" href="ssmfe.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            spral
              <img src="_static/STFC-Logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="csc_format.html">Compressed Sparse Column (CSC) Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="coord_format.html">Coordinate (Coord) Format</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="lsmr.html">LSMR - Sparse Least Squares LSMR Solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_util.html">MATRIX_UTIL - Matrix utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="random.html">RANDOM - Pseudo-random number generator</a></li>
<li class="toctree-l1"><a class="reference internal" href="random_matrix.html">RANDOM_MATRIX - Pseudo-random Matrix Generator</a></li>
<li class="toctree-l1"><a class="reference internal" href="rutherford_boeing.html">RUTHERFORD_BOEING - RB File Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="scaling.html">SCALING - Sparse matrix scalings</a></li>
<li class="toctree-l1"><a class="reference internal" href="ssids.html">SSIDS - Sparse Symmetric Indefinite Direct Solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="ssmfe.html">SSMFE - Sparse Symmetric Matrix-Free Eigensolver</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">SSMFE_EXPERT - Sparse Symmetric Matrix-Free Eigensolver (Expert interface)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#purpose">Purpose</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#major-version-history">Major version history</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#usage-overview">Usage overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#subroutines">Subroutines</a></li>
<li class="toctree-l2"><a class="reference internal" href="#derived-types">Derived types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#preconditioning-example">Preconditioning example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#method">Method</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-algorithm">The algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stopping-criteria">Stopping criteria</a></li>
<li class="toctree-l3"><a class="reference internal" href="#improving-eigenvector-accuracy">Improving eigenvector accuracy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-use-of-shifted-matrix-factorization">The use of shifted matrix factorization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#error-estimation">Error estimation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#standard-problem">Standard problem</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generalized-problem">Generalized problem</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ssmfe_core.html">SSMFE_CORE - Sparse Symmetric Matrix-Free Eigensolver (Core Algorithm)</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">spral</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">SSMFE_EXPERT - Sparse Symmetric Matrix-Free Eigensolver (Expert interface)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/ssmfe_expert.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ssmfe-expert-sparse-symmetric-matrix-free-eigensolver-expert-interface">
<h1>SSMFE_EXPERT - Sparse Symmetric Matrix-Free Eigensolver (Expert interface)<a class="headerlink" href="#ssmfe-expert-sparse-symmetric-matrix-free-eigensolver-expert-interface" title="Link to this heading"></a></h1>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;spral_ssmfe.h&gt;</span><span class="c1"> /* or &lt;spral.h&gt; for all packages */</span>
</pre></div>
</div>
<section id="purpose">
<h2>Purpose<a class="headerlink" href="#purpose" title="Link to this heading"></a></h2>
<p>This package computes extreme (leftmost and/or rightmost)
eigenpairs <span class="math notranslate nohighlight">\(\{\lambda_i, x_i\}\)</span> of the following eigenvalue problems:</p>
<ul>
<li><p>the standard eigenvalue problem</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[A x = \lambda x,\]</div>
</div></blockquote>
</li>
<li><p>the generalized eigenvalue problem</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[A x = \lambda B x,\]</div>
</div></blockquote>
</li>
<li><p>the buckling problem</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[B x = \lambda A x,\]</div>
</div></blockquote>
</li>
</ul>
<p>where <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are <strong>real symmetric</strong> (or <strong>Hermitian</strong>) matrices
and <span class="math notranslate nohighlight">\(B\)</span> is <strong>positive definite</strong>.</p>
<p>The package <a class="reference internal" href="ssmfe.html"><span class="doc">SSMFE</span></a> provides a more user-friendly wrapper around
this code. Conversely, <a class="reference internal" href="ssmfe_core.html"><span class="doc">SSMFE_CORE</span></a> provides a lower level
implementation of the core solver, which this package provides a wrapper for.</p>
<section id="major-version-history">
<h3>Major version history<a class="headerlink" href="#major-version-history" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>2014-11-20 Version 1.0.0</dt><dd><p>Initial release</p>
</dd>
</dl>
<p>[for detail please see ChangeLog]</p>
</section>
</section>
<section id="usage-overview">
<h2>Usage overview<a class="headerlink" href="#usage-overview" title="Link to this heading"></a></h2>
<p>The eigensolver subroutines behind this package implement a
block iterative algorithm. The block nature of this algorithm allows the
user to benefit from highly optimized linear algebra subroutines and
from the ubiquitous multicore architecture of modern computers. It also
makes this algorithm more reliable than Krylov-based algorithms employed
e.g. by ARPACK in the presence of clustered eigenvalues. However,
convergence of the iterations may be slow if the density of the spectrum
is high.</p>
<p>Thus, good performance (in terms of speed) is contingent on the
following two factors:</p>
<ol class="lowerroman simple">
<li><p>the number of desired eigenpairs must be substantial (e.g. not fewer than
the number of CPU cores), and</p></li>
<li><p>the employment of a convergence acceleration technique.</p></li>
</ol>
<p>The acceleration techniques that can be used are shift-and-invert and
preconditioning.</p>
<p>The former requires the direct solution of linear systems
with the matrix <span class="math notranslate nohighlight">\(A\)</span> or its linear combination with <span class="math notranslate nohighlight">\(B\)</span>, for which a
sparse symmetric indefinite solver (such as HSL_MA97 or SPRAL_SSIDS)
can be employed.</p>
<p>The latter applies to the case of positive definite
<span class="math notranslate nohighlight">\(A\)</span> and requires a matrix or an operator <span class="math notranslate nohighlight">\(T\)</span>, called <em>a
preconditioner</em>, such that the vector <span class="math notranslate nohighlight">\(v = T f\)</span> is an
approximation to the solution <span class="math notranslate nohighlight">\(u\)</span> of the system <span class="math notranslate nohighlight">\(A u = f\)</span>
(see the simple <a class="reference internal" href="#example"><span class="std std-ref">example below</span></a>). Note: This
technique is only recommended for experienced users.</p>
<p>In this expert interface, the user must handle storage of all vectors,
facilitating advanced memory handling techniques required for parallel,
hybrid and/or out-of-core execution. If there is no requirement to store
these vectors, consider using the simplified interface of <a class="reference internal" href="ssmfe.html"><span class="doc">SSMFE</span></a>
instead.</p>
</section>
<section id="subroutines">
<h2>Subroutines<a class="headerlink" href="#subroutines" title="Link to this heading"></a></h2>
<p>To use the solver procedures, the user must maintain a workspace of <cite>(kw+1)</cite>
blocks each containing <cite>m</cite> vectors of size <cite>n</cite>. For notational convienience
we refer to this workspace as a C array <code class="docutils literal notranslate"><span class="pre">W[kw+1][m][n]</span></code>, but the user
is free to store it as they wish. The following table provides minimum values
of <cite>kw</cite> for each setup:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head" colspan="2"><p>minAprod=T</p></th>
<th class="head" colspan="2"><p>minAprod=F</p></th>
</tr>
<tr class="row-even"><th class="head"><p>Problem</p></th>
<th class="head"><p>minBprod=T</p></th>
<th class="head"><p>minBprod=F</p></th>
<th class="head"><p>minBprod=T</p></th>
<th class="head"><p>minBprod=F</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>standard</p></td>
<td><p>7</p></td>
<td><p>5</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>standard_shift</p></td>
<td><p>7</p></td>
<td><p>5</p></td>
<td><p>N/A</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>generalized</p></td>
<td><p>7</p></td>
<td><p>5</p></td>
<td><p>5</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>generalized_shift</p></td>
<td><p>7</p></td>
<td><p>7</p></td>
<td><p>N/A</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>buckling</p></td>
<td><p>7</p></td>
<td><p>7</p></td>
<td><p>N/A</p></td>
<td><p>N/A</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Further, the user must also store the converged eigenvectors <span class="math notranslate nohighlight">\(X\)</span>, and
(for generalised problems) their <span class="math notranslate nohighlight">\(B\)</span>-images <span class="math notranslate nohighlight">\(BX\)</span> using
separate storage, e.g. <code class="docutils literal notranslate"><span class="pre">X[mep][n],</span> <span class="pre">BX[mep][n]</span></code>.
For convienence of notation we use the convention that <code class="docutils literal notranslate"><span class="pre">x[i:j]</span></code>
denotes indices <cite>i</cite> through <cite>j</cite> (inclusive) of the vector <cite>x[]</cite>.
In addition to being output, the routine may need to
reorthagonalise against these from time to time.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.spral_ssmfe_default_options">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_ssmfe_default_options</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Intialises members of options structure to default values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>options</strong> – Structure to be initialised.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_ssmfe_expert_standard_double">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_ssmfe_expert_standard_double</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_rcid</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rci</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">left</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mep</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ind</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keep</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform" title="spral_ssmfe_inform"><span class="n"><span class="pre">spral_ssmfe_inform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_ssmfe_expert_standard_double" title="Link to this definition"></a><br /></dt>
<dd><p>Computes the left-most eigenpairs of the standard eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[Ax = \lambda x\]</div>
<p>Optionally uses preconditioning.</p>
<p>Uses reverse-communication. Upon return the user must perform a task
specified by the <cite>rci</cite> parameter and recall the routine. Possible values of
<cite>rci</cite> and associated tasks are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>rci.job</cite></p></th>
<th class="head"><p>Task to be performed</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-3</p></td>
<td><p>None. Fatal error, see <a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform.flag" title="spral_ssmfe_inform.flag"><code class="xref c c-member docutils literal notranslate"><span class="pre">inform.flag</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>-2</p></td>
<td><p>Failed to converge, see
<a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform.flag" title="spral_ssmfe_inform.flag"><code class="xref c c-member docutils literal notranslate"><span class="pre">inform.flag</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p>-1</p></td>
<td><p>None. Computation complete.</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>Calculate <span class="math notranslate nohighlight">\(\bar{V} = AU\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>Apply preconditioner <span class="math notranslate nohighlight">\(\bar{V} = TU\)</span>. (Copy if T=I).</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>Copy converged eigenvectors <span class="math notranslate nohighlight">\(X\)</span> to user storage:</p>
<ul class="simple">
<li><p>If <cite>rci.i&gt;0</cite>: <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx:rci.jx+rci.nx-1][:]</span></code>.</p></li>
<li><p>Else:         <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx-rci.nx+1:rci.jx][:]</span></code>.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>11</p></td>
<td><p>If <cite>rci.i.eq.0</cite>, copy <span class="math notranslate nohighlight">\(\bar{V} = U\)</span>.</p>
<p>Otherwise, reorder columns of block <cite>rci.kx</cite> such that column
<cite>ind[j]</cite> becomes the new column <cite>j</cite> for <cite>j=1, …, rci.nx</cite></p>
<p>Note: if <code class="docutils literal notranslate"><span class="pre">rci.kx==rci.ky</span></code>, only reorder once.</p>
</td>
</tr>
<tr class="row-odd"><td><p>12</p></td>
<td><p>Compute the dot products</p>
<div class="math notranslate nohighlight">
\[r_{ii} = U_i \cdot \bar{V}_i\]</div>
</td>
</tr>
<tr class="row-even"><td><p>13</p></td>
<td><p>Perform the scalings</p>
<div class="math notranslate nohighlight">
\[U_i = U_i/\sqrt{(U_i\cdot \bar{V}_i)}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\bar{V}_i = \bar{V}_i/\sqrt{(U_i\cdot \bar{V}_i)}\]</div>
<p>for each column <span class="math notranslate nohighlight">\(U_i\)</span> and <span class="math notranslate nohighlight">\(\bar{V}_i\)</span> of <span class="math notranslate nohighlight">\(U\)</span>
and <span class="math notranslate nohighlight">\(\bar{V}\)</span>.</p>
<p>Note: if <code class="docutils literal notranslate"><span class="pre">rci.kx</span> <span class="pre">==</span> <span class="pre">rci.ky</span></code>, only scale once.</p>
</td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>Perform the updates</p>
<div class="math notranslate nohighlight">
\[\bar{V}_i = \bar{V}_i + r_{ii} U_i\]</div>
<p>for each column <span class="math notranslate nohighlight">\(\bar{V}_i\)</span> of <span class="math notranslate nohighlight">\(\bar{V}\)</span></p>
</td>
</tr>
<tr class="row-even"><td><p>15</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[R = \alpha U^T V + \beta R\]</div>
</td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[V = \alpha U R + \beta V\]</div>
</td>
</tr>
<tr class="row-even"><td><p>17</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[U = \alpha U R\]</div>
<p>Note: <span class="math notranslate nohighlight">\(V\)</span> may be used as a workspace</p>
</td>
</tr>
<tr class="row-odd"><td><p>21</p></td>
<td><p>Orthogonalize columns of <span class="math notranslate nohighlight">\(V\)</span> to all vectors <span class="math notranslate nohighlight">\(X\)</span>
by solving</p>
<div class="math notranslate nohighlight">
\[(X^TX) Q = X^T \bar{V}\]</div>
<p>for <span class="math notranslate nohighlight">\(Q\)</span> and updating</p>
<div class="math notranslate nohighlight">
\[U = U - XQ\]</div>
</td>
</tr>
<tr class="row-even"><td><p>22</p></td>
<td><p>Orthogonalize columns of <span class="math notranslate nohighlight">\(U\)</span> to all vectors <span class="math notranslate nohighlight">\(X\)</span>
by solving</p>
<div class="math notranslate nohighlight">
\[(X^TX) Q = X^T U\]</div>
<p>for <span class="math notranslate nohighlight">\(Q\)</span> and updating</p>
<div class="math notranslate nohighlight">
\[U = U - XQ\]</div>
</td>
</tr>
<tr class="row-odd"><td><p>999</p></td>
<td><p>Restart:</p>
<p>If <cite>rci.k&gt;0</cite>: Restart suggested with block size
<cite>m &gt;= rci.nx + rci.i + rci.j</cite>, adjusting workspace size
to match. Set <cite>rci.i=0</cite> and <cite>rci.j=0</cite> and recall the routine.
If a restart is not desirable, routine may be recalled with
no change to parameters.</p>
<p>If <cite>rci.k=0</cite>: Restart required with the same block size.</p>
<p>In both cases, the first block <code class="docutils literal notranslate"><span class="pre">W[0][:][:]</span></code> should retain
vectors <code class="docutils literal notranslate"><span class="pre">rci.jx:rci.jx+rci.nx-1</span></code>, filling remaining vectors
randomly such that the entire set of columns is linearly
independent from each other and also from the converged
eigenvectors.</p>
</td>
</tr>
</tbody>
</table>
<p>The matrices are defined as follows:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(U\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx:rci.jx+rci.nx-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(V\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jy:rci.jy+rci.ny-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(\bar{V}\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jy:rci.jy+rci.nx-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(R\)</span> = <code class="docutils literal notranslate"><span class="pre">rr[rci.k][rci.j:rci.j+rci.ny-1][rci.i:rci.i+rci.nx-1]</span></code></p></li>
</ul>
<p>and <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are given by <code class="docutils literal notranslate"><span class="pre">rci.alpha</span></code> and
<code class="docutils literal notranslate"><span class="pre">rci.beta</span></code> respectively. We use the notation <span class="math notranslate nohighlight">\(r_{ii}\)</span> to refer
to the <span class="math notranslate nohighlight">\(i\)</span>-th diagonal element of <span class="math notranslate nohighlight">\(R\)</span>, being
<code class="docutils literal notranslate"><span class="pre">rr[rci.k][rci.j+i-1][rci.i+i-1]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rci</strong> – Reverse communication type.
<code class="xref c c-member docutils literal notranslate"><span class="pre">rci.job</span></code> must be
set to <cite>0</cite> before the first call.</p></li>
<li><p><strong>left</strong> – Number of left eigenpairs to find.</p></li>
<li><p><strong>mep</strong> – Number of working eigenpairs.
See <a class="reference internal" href="#method"><span class="std std-ref">method section</span></a> for guidance on selecting a good
value. Must be at least <cite>left</cite>.</p></li>
<li><p><strong>lambda[mep]</strong> – Current eigenvalue estimates in ascending
order.</p></li>
<li><p><strong>m</strong> – Block size of workspace <cite>W</cite>. Must be at least <cite>2</cite>.</p></li>
<li><p><strong>rr[3][2*m][2*m]</strong> – reverse communication workspace.</p></li>
<li><p><strong>ind[m]</strong> – reverse communication workspace.</p></li>
<li><p><strong>keep</strong> – Internal workspace used by routine.</p></li>
<li><p><strong>options</strong> – specifies algorithm options to be used.</p></li>
<li><p><strong>inform</strong> – returns information about the exection of the
routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_ssmfe_expert_standard_double_complex">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_ssmfe_expert_standard_double_complex</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_rciz</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rci</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">left</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mep</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="kt"><span class="pre">complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ind</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keep</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform" title="spral_ssmfe_inform"><span class="n"><span class="pre">spral_ssmfe_inform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_ssmfe_expert_standard_double_complex" title="Link to this definition"></a><br /></dt>
<dd><p>As <a class="reference internal" href="#c.spral_ssmfe_expert_standard_double" title="spral_ssmfe_expert_standard_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_ssmfe_expert_standard_double()</span></code></a>, but types of <code class="docutils literal notranslate"><span class="pre">rci</span></code>,
and <code class="docutils literal notranslate"><span class="pre">rr</span></code> changed to support type <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">complex</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_ssmfe_expert_standard_shift_double">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_ssmfe_expert_standard_shift_double</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_rcid</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rci</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">sigma</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">left</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">right</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mep</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ind</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keep</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform" title="spral_ssmfe_inform"><span class="n"><span class="pre">spral_ssmfe_inform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_ssmfe_expert_standard_shift_double" title="Link to this definition"></a><br /></dt>
<dd><p>Computes eigenpairs of the standard eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[Ax = \lambda x\]</div>
<p>in the vicinity of a given value <span class="math notranslate nohighlight">\(sigma\)</span>.</p>
<p>Uses reverse-communication. Upon return the user must perform a task
specified by the <cite>rci</cite> parameter and recall the routine. Possible values of
<cite>rci</cite> and associated tasks are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>rci.job</cite></p></th>
<th class="head"><p>Task to be performed</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-3</p></td>
<td><p>None. Fatal error, see <a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform.flag" title="spral_ssmfe_inform.flag"><code class="xref c c-member docutils literal notranslate"><span class="pre">inform.flag</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>-2</p></td>
<td><p>Failed to converge, see
<a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform.flag" title="spral_ssmfe_inform.flag"><code class="xref c c-member docutils literal notranslate"><span class="pre">inform.flag</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p>-1</p></td>
<td><p>None. Computation complete.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Apply preconditioner <span class="math notranslate nohighlight">\(\bar{V} = TU\)</span>. (Copy if T=I).</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>Copy converged eigenvectors <span class="math notranslate nohighlight">\(X\)</span> to user storage:</p>
<ul class="simple">
<li><p>If <cite>rci.i&gt;0</cite>: <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx:rci.jx+rci.nx-1][:]</span></code>.</p></li>
<li><p>Else:         <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx-rci.nx+1:rci.jx][:]</span></code>.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>Compute <span class="math notranslate nohighlight">\(V = (A-\sigma I)^{-1} U\)</span></p></td>
</tr>
<tr class="row-even"><td><p>11</p></td>
<td><p>If <cite>rci.i == 0</cite>, copy <span class="math notranslate nohighlight">\(\bar{V} = U\)</span>.</p>
<p>Otherwise, reorder columns of block <cite>rci.kx</cite> such that column
<cite>ind[j]</cite> becomes the new column <cite>j</cite> for <cite>j=0, …, rci.nx-1</cite></p>
<p>Note: if <code class="docutils literal notranslate"><span class="pre">rci.kx</span> <span class="pre">==</span> <span class="pre">rci.ky</span></code>, only reorder once.</p>
</td>
</tr>
<tr class="row-odd"><td><p>12</p></td>
<td><p>Compute the dot products</p>
<div class="math notranslate nohighlight">
\[r_{ii} = U_i \cdot \bar{V}_i\]</div>
</td>
</tr>
<tr class="row-even"><td><p>13</p></td>
<td><p>Perform the scalings</p>
<div class="math notranslate nohighlight">
\[U_i = U_i/\sqrt{(U_i\cdot \bar{V}_i)}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\bar{V}_i = \bar{V}_i/\sqrt{(U_i\cdot \bar{V}_i)}\]</div>
<p>for each column <span class="math notranslate nohighlight">\(U_i\)</span> and <span class="math notranslate nohighlight">\(\bar{V}_i\)</span> of <span class="math notranslate nohighlight">\(U\)</span>
and <span class="math notranslate nohighlight">\(\bar{V}\)</span>.</p>
<p>Note: if <code class="docutils literal notranslate"><span class="pre">rci.kx</span> <span class="pre">==</span> <span class="pre">rci.ky</span></code>, only scale once.</p>
</td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>Perform the updates</p>
<div class="math notranslate nohighlight">
\[\bar{V}_i = \bar{V}_i + r_{ii} U_i\]</div>
<p>for each column <span class="math notranslate nohighlight">\(\bar{V}_i\)</span> of <span class="math notranslate nohighlight">\(\bar{V}\)</span></p>
</td>
</tr>
<tr class="row-even"><td><p>15</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[R = \alpha U^T V + \beta R\]</div>
</td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[V = \alpha U R + \beta V\]</div>
</td>
</tr>
<tr class="row-even"><td><p>17</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[U = \alpha U R\]</div>
<p>Note: <span class="math notranslate nohighlight">\(V\)</span> may be used as a workspace</p>
</td>
</tr>
<tr class="row-odd"><td><p>21</p></td>
<td><p>Orthogonalize columns of <span class="math notranslate nohighlight">\(V\)</span> to all vectors <span class="math notranslate nohighlight">\(X\)</span>
by solving</p>
<div class="math notranslate nohighlight">
\[(X^TX) Q = X^T \bar{V}\]</div>
<p>for <span class="math notranslate nohighlight">\(Q\)</span> and updating</p>
<div class="math notranslate nohighlight">
\[U = U - XQ\]</div>
</td>
</tr>
<tr class="row-even"><td><p>22</p></td>
<td><p>Orthogonalize columns of <span class="math notranslate nohighlight">\(U\)</span> to all vectors <span class="math notranslate nohighlight">\(X\)</span>
by solving</p>
<div class="math notranslate nohighlight">
\[(X^TX) Q = X^T U\]</div>
<p>for <span class="math notranslate nohighlight">\(Q\)</span> and updating</p>
<div class="math notranslate nohighlight">
\[U = U - XQ\]</div>
</td>
</tr>
<tr class="row-odd"><td><p>999</p></td>
<td><p>Restart:</p>
<p>If <cite>rci.k&gt;0</cite>: Restart suggested with block size
<cite>m &gt;= rci.nx + rci.i + rci.j</cite>, adjusting workspace size
to match. Set <cite>rci.i=0</cite> and <cite>rci.j=0</cite> and recall the routine.
If a restart is not desirable, routine may be recalled with
no change to parameters.</p>
<p>If <cite>rci.k=0</cite>: Restart required with the same block size.</p>
<p>In both cases, the first block <code class="docutils literal notranslate"><span class="pre">W[0][:][:]</span></code> should retain
vectors <code class="docutils literal notranslate"><span class="pre">rci.jx:rci.jx+rci.nx-1</span></code>, filling remaining vectors
randomly such that the entire set of columns is linearly
independent from each other and also from the converged
eigenvectors.</p>
</td>
</tr>
</tbody>
</table>
<p>The matrices are defined as follows:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(U\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx:rci.jx+rci.nx-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(V\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jy:rci.jy+rci.ny-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(\bar{V}\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jy:rci.jy+rci.nx-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(R\)</span> = <code class="docutils literal notranslate"><span class="pre">rr[rci.k][rci.j:rci.j+rci.ny-1][rci.i:rci.i+rci.nx-1]</span></code></p></li>
</ul>
<p>and <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are given by <code class="docutils literal notranslate"><span class="pre">rci.alpha</span></code> and
<code class="docutils literal notranslate"><span class="pre">rci.beta</span></code> respectively. We use the notation <span class="math notranslate nohighlight">\(r_{ii}\)</span> to refer
to the <span class="math notranslate nohighlight">\(i\)</span>-th diagonal element of <span class="math notranslate nohighlight">\(R\)</span>, being
<code class="docutils literal notranslate"><span class="pre">rr[rci.k][rci.j+i-1][rci.i+i-1]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rci</strong> – Reverse communication type.
<code class="xref c c-member docutils literal notranslate"><span class="pre">rci.job</span></code> must be
set to <cite>0</cite> before the first call.</p></li>
<li><p><strong>sigma</strong> – Shift value <span class="math notranslate nohighlight">\(sigma\)</span>.</p></li>
<li><p><strong>left</strong> – Number of left eigenpairs to find.</p></li>
<li><p><strong>right</strong> – Number of right eigenpairs to find.</p></li>
<li><p><strong>mep</strong> – Number of working eigenpairs.
See <a class="reference internal" href="#method"><span class="std std-ref">method section</span></a> for guidance on selecting a good
value. Must be at least <cite>left+right</cite>.</p></li>
<li><p><strong>lambda[mep]</strong> – Current eigenvalue estimates in ascending
order.</p></li>
<li><p><strong>m</strong> – Block size of workspace <cite>W</cite>. Must be at least <cite>2</cite>.</p></li>
<li><p><strong>rr[3][2*m][2*m]</strong> – reverse communication workspace.</p></li>
<li><p><strong>ind[m]</strong> – reverse communication workspace.</p></li>
<li><p><strong>keep</strong> – Internal workspace used by routine.</p></li>
<li><p><strong>options</strong> – specifies algorithm options to be used.</p></li>
<li><p><strong>inform</strong> – returns information about the exection of the
routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_ssmfe_expert_standard_shift_double_complex">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_ssmfe_expert_standard_shift_double_complex</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_rciz</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rci</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">sigma</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">left</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">right</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mep</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="kt"><span class="pre">complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ind</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keep</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform" title="spral_ssmfe_inform"><span class="n"><span class="pre">spral_ssmfe_inform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_ssmfe_expert_standard_shift_double_complex" title="Link to this definition"></a><br /></dt>
<dd><p>As <a class="reference internal" href="#c.spral_ssmfe_expert_standard_shift_double" title="spral_ssmfe_expert_standard_shift_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_ssmfe_expert_standard_shift_double()</span></code></a>, but types of
<code class="docutils literal notranslate"><span class="pre">rci</span></code>, and <code class="docutils literal notranslate"><span class="pre">rr</span></code> changed to support type <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">complex</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_ssmfe_expert_generalized_double">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_ssmfe_expert_generalized_double</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_rcid</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rci</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">left</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mep</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ind</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keep</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform" title="spral_ssmfe_inform"><span class="n"><span class="pre">spral_ssmfe_inform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_ssmfe_expert_generalized_double" title="Link to this definition"></a><br /></dt>
<dd><p>Computes the left-most eigenpairs of the generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[Ax = \lambda B x\]</div>
<p>Optionally uses preconditioning.</p>
<p>Uses reverse-communication. Upon return the user must perform a task
specified by the <cite>rci</cite> parameter and recall the routine. Possible values of
<cite>rci</cite> and associated tasks are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>rci.job</cite></p></th>
<th class="head"><p>Task to be performed</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-3</p></td>
<td><p>None. Fatal error, see <a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform.flag" title="spral_ssmfe_inform.flag"><code class="xref c c-member docutils literal notranslate"><span class="pre">inform.flag</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>-2</p></td>
<td><p>Failed to converge, see
<a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform.flag" title="spral_ssmfe_inform.flag"><code class="xref c c-member docutils literal notranslate"><span class="pre">inform.flag</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p>-1</p></td>
<td><p>None. Computation complete.</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>Calculate <span class="math notranslate nohighlight">\(\bar{V} = AU\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>Apply preconditioner <span class="math notranslate nohighlight">\(\bar{V} = TU\)</span>. (Copy if T=I).</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>Compute <span class="math notranslate nohighlight">\(\bar{V} = BU\)</span></p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>Copy converged eigenvectors <span class="math notranslate nohighlight">\(X\)</span> to user storage:</p>
<ul class="simple">
<li><p>If <cite>rci.i&gt;0</cite>: <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx:rci.jx+rci.nx-1][:]</span></code>.</p></li>
<li><p>Else:         <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx-rci.nx+1:rci.jx][:]</span></code>.</p></li>
</ul>
<p>Optionally save their <span class="math notranslate nohighlight">\(B\)</span>-images:</p>
<ul class="simple">
<li><p>If <cite>rci.i&gt;0</cite>: <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jx:rci.jx+rci.nx-1][:]</span></code>.</p></li>
<li><p>Else:         <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jx-rci.nx+1:rci.jx][:]</span></code>.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>11</p></td>
<td><p>If <cite>rci.i == 0</cite>, copy <span class="math notranslate nohighlight">\(\bar{V} = U\)</span>.</p>
<p>Otherwise, reorder columns of block <cite>rci.kx</cite> such that column
<cite>ind[j]</cite> becomes the new column <cite>j</cite> for <cite>j=0, …, rci.nx-1</cite></p>
<p>Note: if <code class="docutils literal notranslate"><span class="pre">rci.kx</span> <span class="pre">==</span> <span class="pre">rci.ky</span></code>, only reorder once.</p>
</td>
</tr>
<tr class="row-even"><td><p>12</p></td>
<td><p>Compute the dot products</p>
<div class="math notranslate nohighlight">
\[r_{ii} = U_i \cdot \bar{V}_i\]</div>
</td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>Perform the scalings</p>
<div class="math notranslate nohighlight">
\[U_i = U_i/\sqrt{(U_i\cdot \bar{V}_i)}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\bar{V}_i = \bar{V}_i/\sqrt{(U_i\cdot \bar{V}_i)}\]</div>
<p>for each column <span class="math notranslate nohighlight">\(U_i\)</span> and <span class="math notranslate nohighlight">\(\bar{V}_i\)</span> of <span class="math notranslate nohighlight">\(U\)</span>
and <span class="math notranslate nohighlight">\(\bar{V}\)</span>.</p>
<p>Note: if <code class="docutils literal notranslate"><span class="pre">rci.kx</span> <span class="pre">==</span> <span class="pre">rci.ky</span></code>, only scale once.</p>
</td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>Perform the updates</p>
<div class="math notranslate nohighlight">
\[\bar{V}_i = \bar{V}_i + r_{ii} U_i\]</div>
<p>for each column <span class="math notranslate nohighlight">\(\bar{V}_i\)</span> of <span class="math notranslate nohighlight">\(\bar{V}\)</span></p>
</td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[R = \alpha U^T V + \beta R\]</div>
</td>
</tr>
<tr class="row-even"><td><p>16</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[V = \alpha U R + \beta V\]</div>
</td>
</tr>
<tr class="row-odd"><td><p>17</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[U = \alpha U R\]</div>
<p>Note: <span class="math notranslate nohighlight">\(V\)</span> may be used as a workspace</p>
</td>
</tr>
<tr class="row-even"><td><p>21</p></td>
<td><p><span class="math notranslate nohighlight">\(B\)</span>-orthogonalize columns of <span class="math notranslate nohighlight">\(V\)</span> to all vectors
<span class="math notranslate nohighlight">\(X\)</span> by solving</p>
<div class="math notranslate nohighlight">
\[(X^TBX) Q = X^T \bar{V}\]</div>
<p>for <span class="math notranslate nohighlight">\(Q\)</span> and updating</p>
<div class="math notranslate nohighlight">
\[\begin{split}U       &amp; = &amp; U - XQ \\
\bar{V} &amp; = &amp; \bar{V} - BXQ\end{split}\]</div>
<p>The update of <span class="math notranslate nohighlight">\(\bar{V}\)</span> may be replaced by</p>
<div class="math notranslate nohighlight">
\[\bar{V} = BU\]</div>
</td>
</tr>
<tr class="row-odd"><td><p>22</p></td>
<td><p><span class="math notranslate nohighlight">\(B\)</span>-orthogonalize columns of <span class="math notranslate nohighlight">\(U\)</span> to all vectors
<span class="math notranslate nohighlight">\(X\)</span> by solving</p>
<div class="math notranslate nohighlight">
\[(X^TBX) Q = X^T U\]</div>
<p>for <span class="math notranslate nohighlight">\(Q\)</span> and updating</p>
<div class="math notranslate nohighlight">
\[U = U - BXQ\]</div>
</td>
</tr>
<tr class="row-even"><td><p>999</p></td>
<td><p>Restart:</p>
<p>If <cite>rci.k&gt;0</cite>: Restart suggested with block size
<cite>m &gt;= rci.nx + rci.i + rci.j</cite>, adjusting workspace size
to match. Set <cite>rci.i=0</cite> and <cite>rci.j=0</cite> and recall the routine.
If a restart is not desirable, routine may be recalled with
no change to parameters.</p>
<p>If <cite>rci.k=0</cite>: Restart required with the same block size.</p>
<p>In both cases, the first block <code class="docutils literal notranslate"><span class="pre">W[0][:][:]</span></code> should retain
vectors <code class="docutils literal notranslate"><span class="pre">rci.jx:rci.jx+rci.nx-1</span></code>, filling remaining vectors
randomly such that the entire set of columns is linearly
independent from each other and also from the converged
eigenvectors.</p>
</td>
</tr>
</tbody>
</table>
<p>The matrices are defined as follows:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(U\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx:rci.jx+rci.nx-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(V\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jy:rci.jy+rci.ny-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(\bar{V}\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jy:rci.jy+rci.nx-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(R\)</span> = <code class="docutils literal notranslate"><span class="pre">rr[rci.k][rci.j:rci.j+rci.ny-1][rci.i:rci.i+rci.nx-1]</span></code></p></li>
</ul>
<p>and <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are given by <code class="docutils literal notranslate"><span class="pre">rci.alpha</span></code> and
<code class="docutils literal notranslate"><span class="pre">rci.beta</span></code> respectively. We use the notation <span class="math notranslate nohighlight">\(r_{ii}\)</span> to refer
to the <span class="math notranslate nohighlight">\(i\)</span>-th diagonal element of <span class="math notranslate nohighlight">\(R\)</span>, being
<code class="docutils literal notranslate"><span class="pre">rr[rci.k][rci.j+i-1][rci.i+i-1]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rci</strong> – Reverse communication type.
<code class="xref c c-member docutils literal notranslate"><span class="pre">rci.job</span></code> must be
set to <cite>0</cite> before the first call.</p></li>
<li><p><strong>left</strong> – Number of left eigenpairs to find.</p></li>
<li><p><strong>mep</strong> – Number of working eigenpairs.
See <a class="reference internal" href="#method"><span class="std std-ref">method section</span></a> for guidance on selecting a good
value. Must be at least <cite>left</cite>.</p></li>
<li><p><strong>lambda[mep]</strong> – Current eigenvalue estimates in ascending
order.</p></li>
<li><p><strong>m</strong> – Block size of workspace <cite>W</cite>. Must be at least <cite>2</cite>.</p></li>
<li><p><strong>rr[3][2*m][2*m]</strong> – reverse communication workspace.</p></li>
<li><p><strong>ind[m]</strong> – reverse communication workspace.</p></li>
<li><p><strong>keep</strong> – Internal workspace used by routine.</p></li>
<li><p><strong>options</strong> – specifies algorithm options to be used.</p></li>
<li><p><strong>inform</strong> – returns information about the exection of the
routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_ssmfe_expert_generalized_double_complex">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_ssmfe_expert_generalized_double_complex</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_rciz</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rci</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">left</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mep</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="kt"><span class="pre">complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ind</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keep</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform" title="spral_ssmfe_inform"><span class="n"><span class="pre">spral_ssmfe_inform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_ssmfe_expert_generalized_double_complex" title="Link to this definition"></a><br /></dt>
<dd><p>As <a class="reference internal" href="#c.spral_ssmfe_expert_generalized_double" title="spral_ssmfe_expert_generalized_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_ssmfe_expert_generalized_double()</span></code></a>, but types of
<code class="docutils literal notranslate"><span class="pre">rci</span></code> and <code class="docutils literal notranslate"><span class="pre">rr</span></code> changed to support type <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">complex</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_ssmfe_expert_generalized_shift_double">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_ssmfe_expert_generalized_shift_double</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_rcid</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rci</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">sigma</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">left</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">right</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mep</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ind</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keep</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform" title="spral_ssmfe_inform"><span class="n"><span class="pre">spral_ssmfe_inform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_ssmfe_expert_generalized_shift_double" title="Link to this definition"></a><br /></dt>
<dd><p>Computes eigenpairs of the generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[Ax = \lambda B x\]</div>
<p>in the vicinity of a given value <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
<p>Uses reverse-communication. Upon return the user must perform a task
specified by the <cite>rci</cite> parameter and recall the routine. Possible values of
<cite>rci</cite> and associated tasks are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>rci.job</cite></p></th>
<th class="head"><p>Task to be performed</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-3</p></td>
<td><p>None. Fatal error, see <a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform.flag" title="spral_ssmfe_inform.flag"><code class="xref c c-member docutils literal notranslate"><span class="pre">inform.flag</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>-2</p></td>
<td><p>Failed to converge, see
<a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform.flag" title="spral_ssmfe_inform.flag"><code class="xref c c-member docutils literal notranslate"><span class="pre">inform.flag</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p>-1</p></td>
<td><p>None. Computation complete.</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>Compute <span class="math notranslate nohighlight">\(\bar{V} = BU\)</span></p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>Copy converged eigenvectors <span class="math notranslate nohighlight">\(X\)</span> to user storage:</p>
<ul class="simple">
<li><p>If <cite>rci.i&gt;0</cite>: <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx:rci.jx+rci.nx-1][:]</span></code>.</p></li>
<li><p>Else:         <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx-rci.nx+1:rci.jx][:]</span></code>.</p></li>
</ul>
<p>Optionally save their <span class="math notranslate nohighlight">\(B\)</span>-images:</p>
<ul class="simple">
<li><p>If <cite>rci.i&gt;0</cite>: <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jx:rci.jx+rci.nx-1][:]</span></code>.</p></li>
<li><p>Else:         <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jx-rci.nx+1:rci.jx][:]</span></code>.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>Compute <span class="math notranslate nohighlight">\(V = (A-\sigma B)^{-1} U\)</span></p></td>
</tr>
<tr class="row-even"><td><p>11</p></td>
<td><p>If <cite>rci.i == 0</cite>, copy <span class="math notranslate nohighlight">\(\bar{V} = U\)</span>.</p>
<p>Otherwise, reorder columns of block <cite>rci.kx</cite> such that column
<cite>ind[j]</cite> becomes the new column <cite>j</cite> for <cite>j=0, …, rci.nx-1</cite></p>
<p>Note: if <code class="docutils literal notranslate"><span class="pre">rci.kx</span> <span class="pre">==</span> <span class="pre">rci.ky</span></code>, only reorder once.</p>
</td>
</tr>
<tr class="row-odd"><td><p>12</p></td>
<td><p>Compute the dot products</p>
<div class="math notranslate nohighlight">
\[r_{ii} = U_i \cdot \bar{V}_i\]</div>
</td>
</tr>
<tr class="row-even"><td><p>13</p></td>
<td><p>Perform the scalings</p>
<div class="math notranslate nohighlight">
\[U_i = U_i/\sqrt{(U_i\cdot \bar{V}_i)}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\bar{V}_i = \bar{V}_i/\sqrt{(U_i\cdot \bar{V}_i)}\]</div>
<p>for each column <span class="math notranslate nohighlight">\(U_i\)</span> and <span class="math notranslate nohighlight">\(\bar{V}_i\)</span> of <span class="math notranslate nohighlight">\(U\)</span>
and <span class="math notranslate nohighlight">\(\bar{V}\)</span>.</p>
<p>Note: if <code class="docutils literal notranslate"><span class="pre">rci.kx</span> <span class="pre">==</span> <span class="pre">rci.ky</span></code>, only scale once.</p>
</td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>Perform the updates</p>
<div class="math notranslate nohighlight">
\[\bar{V}_i = \bar{V}_i + r_{ii} U_i\]</div>
<p>for each column <span class="math notranslate nohighlight">\(\bar{V}_i\)</span> of <span class="math notranslate nohighlight">\(\bar{V}\)</span></p>
</td>
</tr>
<tr class="row-even"><td><p>15</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[R = \alpha U^T V + \beta R\]</div>
</td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[V = \alpha U R + \beta V\]</div>
</td>
</tr>
<tr class="row-even"><td><p>17</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[U = \alpha U R\]</div>
<p>Note: <span class="math notranslate nohighlight">\(V\)</span> may be used as a workspace</p>
</td>
</tr>
<tr class="row-odd"><td><p>21</p></td>
<td><p><span class="math notranslate nohighlight">\(B\)</span>-orthogonalize columns of <span class="math notranslate nohighlight">\(V\)</span> to all vectors
<span class="math notranslate nohighlight">\(X\)</span> by solving</p>
<div class="math notranslate nohighlight">
\[(X^TBX) Q = X^T \bar{V}\]</div>
<p>for <span class="math notranslate nohighlight">\(Q\)</span> and updating</p>
<div class="math notranslate nohighlight">
\[\begin{split}U       &amp; = &amp; U - XQ \\
\bar{V} &amp; = &amp; \bar{V} - BXQ\end{split}\]</div>
<p>The update of <span class="math notranslate nohighlight">\(\bar{V}\)</span> may be replaced by</p>
<div class="math notranslate nohighlight">
\[\bar{V} = BU\]</div>
</td>
</tr>
<tr class="row-even"><td><p>22</p></td>
<td><p><span class="math notranslate nohighlight">\(B\)</span>-orthogonalize columns of <span class="math notranslate nohighlight">\(U\)</span> to all vectors
<span class="math notranslate nohighlight">\(X\)</span> by solving</p>
<div class="math notranslate nohighlight">
\[(X^TBX) Q = X^T U\]</div>
<p>for <span class="math notranslate nohighlight">\(Q\)</span> and updating</p>
<div class="math notranslate nohighlight">
\[U = U - BXQ\]</div>
</td>
</tr>
<tr class="row-odd"><td><p>999</p></td>
<td><p>Restart:</p>
<p>If <cite>rci.k&gt;0</cite>: Restart suggested with block size
<cite>m &gt;= rci.nx + rci.i + rci.j</cite>, adjusting workspace size
to match. Set <cite>rci.i=0</cite> and <cite>rci.j=0</cite> and recall the routine.
If a restart is not desirable, routine may be recalled with
no change to parameters.</p>
<p>If <cite>rci.k=0</cite>: Restart required with the same block size.</p>
<p>In both cases, the first block <code class="docutils literal notranslate"><span class="pre">W[0][:][:]</span></code> should retain
vectors <code class="docutils literal notranslate"><span class="pre">rci.jx:rci.jx+rci.nx-1</span></code>, filling remaining vectors
randomly such that the entire set of columns is linearly
independent from each other and also from the converged
eigenvectors.</p>
</td>
</tr>
</tbody>
</table>
<p>The matrices are defined as follows:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(U\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx:rci.jx+rci.nx-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(V\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jy:rci.jy+rci.ny-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(\bar{V}\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jy:rci.jy+rci.nx-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(R\)</span> = <code class="docutils literal notranslate"><span class="pre">rr[rci.k][rci.j:rci.j+rci.ny-1][rci.i:rci.i+rci.nx-1]</span></code></p></li>
</ul>
<p>and <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are given by <code class="docutils literal notranslate"><span class="pre">rci.alpha</span></code> and
<code class="docutils literal notranslate"><span class="pre">rci.beta</span></code> respectively. We use the notation <span class="math notranslate nohighlight">\(r_{ii}\)</span> to refer
to the <span class="math notranslate nohighlight">\(i\)</span>-th diagonal element of <span class="math notranslate nohighlight">\(R\)</span>, being
<code class="docutils literal notranslate"><span class="pre">rr[rci.k][rci.j+i-1][rci.i+i-1]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rci</strong> – Reverse communication type.
<code class="xref c c-member docutils literal notranslate"><span class="pre">rci.job</span></code> must be
set to <cite>0</cite> before the first call.</p></li>
<li><p><strong>sigma</strong> – Shift value <span class="math notranslate nohighlight">\(sigma\)</span>.</p></li>
<li><p><strong>left</strong> – Number of left eigenpairs to find.</p></li>
<li><p><strong>right</strong> – Number of right eigenpairs to find.</p></li>
<li><p><strong>mep</strong> – Number of working eigenpairs.
See <a class="reference internal" href="#method"><span class="std std-ref">method section</span></a> for guidance on selecting a good
value. Must be at least <cite>left+right</cite>.</p></li>
<li><p><strong>lambda[mep]</strong> – Current eigenvalue estimates in ascending
order.</p></li>
<li><p><strong>m</strong> – Block size of workspace <cite>W</cite>. Must be at least <cite>2</cite>.</p></li>
<li><p><strong>rr[3][2*m][2*m]</strong> – reverse communication workspace.</p></li>
<li><p><strong>ind[m]</strong> – reverse communication workspace.</p></li>
<li><p><strong>keep</strong> – Internal workspace used by routine.</p></li>
<li><p><strong>options</strong> – specifies algorithm options to be used.</p></li>
<li><p><strong>inform</strong> – returns information about the exection of the
routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_ssmfe_expert_generalized_shift_double_complex">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_ssmfe_expert_generalized_shift_double_complex</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_rciz</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rci</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">sigma</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">left</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">right</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mep</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="kt"><span class="pre">complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ind</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keep</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform" title="spral_ssmfe_inform"><span class="n"><span class="pre">spral_ssmfe_inform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_ssmfe_expert_generalized_shift_double_complex" title="Link to this definition"></a><br /></dt>
<dd><p>As <a class="reference internal" href="#c.spral_ssmfe_expert_generalized_shift_double" title="spral_ssmfe_expert_generalized_shift_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_ssmfe_expert_generalized_shift_double()</span></code></a>, but types of
<code class="docutils literal notranslate"><span class="pre">rci</span></code>, and <code class="docutils literal notranslate"><span class="pre">rr</span></code> changed to support type <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">complex</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_ssmfe_expert_buckling_double">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_ssmfe_expert_buckling_double</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_rcid</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rci</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">sigma</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">left</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">right</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mep</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ind</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keep</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform" title="spral_ssmfe_inform"><span class="n"><span class="pre">spral_ssmfe_inform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_ssmfe_expert_buckling_double" title="Link to this definition"></a><br /></dt>
<dd><p>Computes the eigenpairs of the buckling problem</p>
<div class="math notranslate nohighlight">
\[Bx = \lambda A x\]</div>
<p>in the vicinity of a given value <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
<p>Uses reverse-communication. Upon return the user must perform a task
specified by the <cite>rci</cite> parameter and recall the routine. Possible values of
<cite>rci</cite> and associated tasks are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>rci.job</cite></p></th>
<th class="head"><p>Task to be performed</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-3</p></td>
<td><p>None. Fatal error, see <a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform.flag" title="spral_ssmfe_inform.flag"><code class="xref c c-member docutils literal notranslate"><span class="pre">inform.flag</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>-2</p></td>
<td><p>Failed to converge, see
<a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform.flag" title="spral_ssmfe_inform.flag"><code class="xref c c-member docutils literal notranslate"><span class="pre">inform.flag</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p>-1</p></td>
<td><p>None. Computation complete.</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>Compute <span class="math notranslate nohighlight">\(\bar{V} = BU\)</span></p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>Copy converged eigenvectors <span class="math notranslate nohighlight">\(X\)</span> to user storage:</p>
<ul class="simple">
<li><p>If <cite>rci.i&gt;0</cite>: <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx:rci.jx+rci.nx-1][:]</span></code>.</p></li>
<li><p>Else:         <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx-rci.nx+1:rci.jx][:]</span></code>.</p></li>
</ul>
<p>Optionally save their <span class="math notranslate nohighlight">\(B\)</span>-images:</p>
<ul class="simple">
<li><p>If <cite>rci.i&gt;0</cite>: <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jx:rci.jx+rci.nx-1][:]</span></code>.</p></li>
<li><p>Else:         <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jx-rci.nx+1:rci.jx][:]</span></code>.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>Compute <span class="math notranslate nohighlight">\(V = (B-\sigma A)^{-1} U\)</span></p></td>
</tr>
<tr class="row-even"><td><p>11</p></td>
<td><p>If <cite>rci.i == 0</cite>, copy <span class="math notranslate nohighlight">\(\bar{V} = U\)</span>.</p>
<p>Otherwise, reorder columns of block <cite>rci.kx</cite> such that column
<cite>ind[j]</cite> becomes the new column <cite>j</cite> for <cite>j=0, …, rci.nx-1</cite></p>
<p>Note: if <code class="docutils literal notranslate"><span class="pre">rci.kx</span> <span class="pre">==</span> <span class="pre">rci.ky</span></code>, only reorder once.</p>
</td>
</tr>
<tr class="row-odd"><td><p>12</p></td>
<td><p>Compute the dot products</p>
<div class="math notranslate nohighlight">
\[r_{ii} = U_i \cdot \bar{V}_i\]</div>
</td>
</tr>
<tr class="row-even"><td><p>13</p></td>
<td><p>Perform the scalings</p>
<div class="math notranslate nohighlight">
\[U_i = U_i/\sqrt{(U_i\cdot \bar{V}_i)}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\bar{V}_i = \bar{V}_i/\sqrt{(U_i\cdot \bar{V}_i)}\]</div>
<p>for each column <span class="math notranslate nohighlight">\(U_i\)</span> and <span class="math notranslate nohighlight">\(\bar{V}_i\)</span> of <span class="math notranslate nohighlight">\(U\)</span>
and <span class="math notranslate nohighlight">\(\bar{V}\)</span>.</p>
<p>Note: if <code class="docutils literal notranslate"><span class="pre">rci.kx</span> <span class="pre">==</span> <span class="pre">rci.ky</span></code>, only scale once.</p>
</td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>Perform the updates</p>
<div class="math notranslate nohighlight">
\[\bar{V}_i = \bar{V}_i + r_{ii} U_i\]</div>
<p>for each column <span class="math notranslate nohighlight">\(\bar{V}_i\)</span> of <span class="math notranslate nohighlight">\(\bar{V}\)</span></p>
</td>
</tr>
<tr class="row-even"><td><p>15</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[R = \alpha U^T V + \beta R\]</div>
</td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[V = \alpha U R + \beta V\]</div>
</td>
</tr>
<tr class="row-even"><td><p>17</p></td>
<td><p>Perform the update</p>
<div class="math notranslate nohighlight">
\[U = \alpha U R\]</div>
<p>Note: <span class="math notranslate nohighlight">\(V\)</span> may be used as a workspace</p>
</td>
</tr>
<tr class="row-odd"><td><p>21</p></td>
<td><p><span class="math notranslate nohighlight">\(B\)</span>-orthogonalize columns of <span class="math notranslate nohighlight">\(V\)</span> to all vectors
<span class="math notranslate nohighlight">\(X\)</span> by solving</p>
<div class="math notranslate nohighlight">
\[(X^TBX) Q = X^T \bar{V}\]</div>
<p>for <span class="math notranslate nohighlight">\(Q\)</span> and updating</p>
<div class="math notranslate nohighlight">
\[\begin{split}U       &amp; = &amp; U - XQ \\
\bar{V} &amp; = &amp; \bar{V} - BXQ\end{split}\]</div>
<p>The update of <span class="math notranslate nohighlight">\(\bar{V}\)</span> may be replaced by</p>
<div class="math notranslate nohighlight">
\[\bar{V} = BU\]</div>
</td>
</tr>
<tr class="row-even"><td><p>22</p></td>
<td><p><span class="math notranslate nohighlight">\(B\)</span>-orthogonalize columns of <span class="math notranslate nohighlight">\(U\)</span> to all vectors
<span class="math notranslate nohighlight">\(X\)</span> by solving</p>
<div class="math notranslate nohighlight">
\[(X^TBX) Q = X^T U\]</div>
<p>for <span class="math notranslate nohighlight">\(Q\)</span> and updating</p>
<div class="math notranslate nohighlight">
\[U = U - BXQ\]</div>
</td>
</tr>
<tr class="row-odd"><td><p>999</p></td>
<td><p>Restart:</p>
<p>If <cite>rci.k&gt;0</cite>: Restart suggested with block size
<cite>m &gt;= rci.nx + rci.i + rci.j</cite>, adjusting workspace size
to match. Set <cite>rci.i=0</cite> and <cite>rci.j=0</cite> and recall the routine.
If a restart is not desirable, routine may be recalled with
no change to parameters.</p>
<p>If <cite>rci.k=0</cite>: Restart required with the same block size.</p>
<p>In both cases, the first block <code class="docutils literal notranslate"><span class="pre">W[0][:][:]</span></code> should retain
vectors <code class="docutils literal notranslate"><span class="pre">rci.jx:rci.jx+rci.nx-1</span></code>, filling remaining vectors
randomly such that the entire set of columns is linearly
independent from each other and also from the converged
eigenvectors.</p>
</td>
</tr>
</tbody>
</table>
<p>The matrices are defined as follows:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(U\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.kx][rci.jx:rci.jx+rci.nx-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(V\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jy:rci.jy+rci.ny-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(\bar{V}\)</span> = <code class="docutils literal notranslate"><span class="pre">W[rci.ky][rci.jy:rci.jy+rci.nx-1][:]</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(R\)</span> = <code class="docutils literal notranslate"><span class="pre">rr[rci.k][rci.j:rci.j+rci.ny-1][rci.i:rci.i+rci.nx-1]</span></code></p></li>
</ul>
<p>and <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are given by <code class="docutils literal notranslate"><span class="pre">rci.alpha</span></code> and
<code class="docutils literal notranslate"><span class="pre">rci.beta</span></code> respectively. We use the notation <span class="math notranslate nohighlight">\(r_{ii}\)</span> to refer
to the <span class="math notranslate nohighlight">\(i\)</span>-th diagonal element of <span class="math notranslate nohighlight">\(R\)</span>, being
<code class="docutils literal notranslate"><span class="pre">rr[rci.k][rci.j+i-1][rci.i+i-1]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rci</strong> – Reverse communication type.
<code class="xref c c-member docutils literal notranslate"><span class="pre">rci.job</span></code> must be
set to <cite>0</cite> before the first call.</p></li>
<li><p><strong>sigma</strong> – Shift value <span class="math notranslate nohighlight">\(sigma\)</span>.</p></li>
<li><p><strong>left</strong> – Number of left eigenpairs to find.</p></li>
<li><p><strong>right</strong> – Number of right eigenpairs to find.</p></li>
<li><p><strong>mep</strong> – Number of working eigenpairs.
See <a class="reference internal" href="#method"><span class="std std-ref">method section</span></a> for guidance on selecting a good
value. Must be at least <cite>left+right</cite>.</p></li>
<li><p><strong>lambda[mep]</strong> – Current eigenvalue estimates in ascending
order.</p></li>
<li><p><strong>m</strong> – Block size of workspace <cite>W</cite>. Must be at least <cite>2</cite>.</p></li>
<li><p><strong>rr[3][2*m][2*m]</strong> – reverse communication workspace.</p></li>
<li><p><strong>ind[m]</strong> – reverse communication workspace.</p></li>
<li><p><strong>keep</strong> – Internal workspace used by routine.</p></li>
<li><p><strong>options</strong> – specifies algorithm options to be used.</p></li>
<li><p><strong>inform</strong> – returns information about the exection of the
routine.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_ssmfe_expert_buckling_double_complex">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_ssmfe_expert_buckling_double_complex</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_rciz</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rci</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">sigma</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">left</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">right</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mep</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="kt"><span class="pre">complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ind</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keep</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">spral_ssmfe_options</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform" title="spral_ssmfe_inform"><span class="n"><span class="pre">spral_ssmfe_inform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_ssmfe_expert_buckling_double_complex" title="Link to this definition"></a><br /></dt>
<dd><p>As <a class="reference internal" href="#c.spral_ssmfe_expert_buckling_double" title="spral_ssmfe_expert_buckling_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_ssmfe_expert_buckling_double()</span></code></a>, but types of
<code class="docutils literal notranslate"><span class="pre">rci</span></code>, and <code class="docutils literal notranslate"><span class="pre">rr</span></code> changed to support type <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">complex</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.spral_ssmfe_expert_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spral_ssmfe_expert_free</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keep</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="ssmfe.html#c.spral_ssmfe_inform" title="spral_ssmfe_inform"><span class="n"><span class="pre">spral_ssmfe_inform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inform</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spral_ssmfe_expert_free" title="Link to this definition"></a><br /></dt>
<dd><p>Free memory allocated in <cite>keep</cite> and <cite>inform</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>keep</strong> – Workspace to be freed.</p></li>
<li><p><strong>inform</strong> – Information type to be freed.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>As memory in <code class="docutils literal notranslate"><span class="pre">keep</span></code> and <code class="docutils literal notranslate"><span class="pre">inform</span></code> has been allocated using Fortran
functions, this routine <strong>must</strong> be called to avoid a memory leak.</p>
</div>
</dd></dl>

</section>
<section id="derived-types">
<h2>Derived types<a class="headerlink" href="#derived-types" title="Link to this heading"></a></h2>
<dl class="c type">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">struct</span> <span class="pre">spral_ssmfe_rcid</span></span></dt>
<dd><p>Real-valued reverse communication interface (RCI) type.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.job">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">job</span></span></span><br /></dt>
<dd><p>Reverse-communication task to perform.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.jx">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">jx</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.jx" title="Link to this definition"></a><br /></dt>
<dd><p>First column of <span class="math notranslate nohighlight">\(U\)</span> in block.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.kx">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kx</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.kx" title="Link to this definition"></a><br /></dt>
<dd><p>Block to which <span class="math notranslate nohighlight">\(U\)</span> belongs.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.nx">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nx</span></span></span><br /></dt>
<dd><p>Number of columns in <span class="math notranslate nohighlight">\(U\)</span> and <span class="math notranslate nohighlight">\(\bar{V}\)</span>, and
number of rows in <span class="math notranslate nohighlight">\(R\)</span>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.jy">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">jy</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.jy" title="Link to this definition"></a><br /></dt>
<dd><p>First column of <span class="math notranslate nohighlight">\(V\)</span> in block.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.ky">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ky</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.ky" title="Link to this definition"></a><br /></dt>
<dd><p>Block to which <span class="math notranslate nohighlight">\(V\)</span> belongs.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.ny">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ny</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.ny" title="Link to this definition"></a><br /></dt>
<dd><p>Number of columns in <span class="math notranslate nohighlight">\(V\)</span> and <span class="math notranslate nohighlight">\(R\)</span>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.i">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.i" title="Link to this definition"></a><br /></dt>
<dd><p>First row of <span class="math notranslate nohighlight">\(R\)</span> in <code class="docutils literal notranslate"><span class="pre">rr(:,:,:)</span></code>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.j">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">j</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.j" title="Link to this definition"></a><br /></dt>
<dd><p>First column of <span class="math notranslate nohighlight">\(R\)</span> in <code class="docutils literal notranslate"><span class="pre">rr(:,:,:)</span></code>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.k">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.k" title="Link to this definition"></a><br /></dt>
<dd><p>Block of <span class="math notranslate nohighlight">\(R\)</span> in <code class="docutils literal notranslate"><span class="pre">rr(:,:,:)</span></code>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.alpha">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">alpha</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.alpha" title="Link to this definition"></a><br /></dt>
<dd><p>Coefficient for matrix multiplication.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.beta">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">beta</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.beta" title="Link to this definition"></a><br /></dt>
<dd><p>Coefficient for matrix multiplication.</p>
</dd></dl>

</dd></dl>

<dl class="c type">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">struct</span> <span class="pre">spral_ssmfe_rciz</span></span></dt>
<dd><p>Complex-valued reverse communication interface (RCI) type.</p>
<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">job</span></span></span><br /></dt>
<dd><p>Reverse-communication task to perform.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">jx</span></span></span><br /></dt>
<dd><p>First column of <span class="math notranslate nohighlight">\(U\)</span> in block.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kx</span></span></span><br /></dt>
<dd><p>Block to which <span class="math notranslate nohighlight">\(U\)</span> belongs.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nx</span></span></span><br /></dt>
<dd><p>Number of columns in <span class="math notranslate nohighlight">\(U\)</span> and <span class="math notranslate nohighlight">\(\bar{V}\)</span>, and
number of rows in <span class="math notranslate nohighlight">\(R\)</span>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">jy</span></span></span><br /></dt>
<dd><p>First column of <span class="math notranslate nohighlight">\(V\)</span> in block.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ky</span></span></span><br /></dt>
<dd><p>Block to which <span class="math notranslate nohighlight">\(V\)</span> belongs.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ny</span></span></span><br /></dt>
<dd><p>Number of columns in <span class="math notranslate nohighlight">\(V\)</span> and <span class="math notranslate nohighlight">\(R\)</span>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i</span></span></span><br /></dt>
<dd><p>First row of <span class="math notranslate nohighlight">\(R\)</span> in <code class="docutils literal notranslate"><span class="pre">rr(:,:,:)</span></code>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">j</span></span></span><br /></dt>
<dd><p>First column of <span class="math notranslate nohighlight">\(R\)</span> in <code class="docutils literal notranslate"><span class="pre">rr(:,:,:)</span></code>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">k</span></span></span><br /></dt>
<dd><p>Block of <span class="math notranslate nohighlight">\(R\)</span> in <code class="docutils literal notranslate"><span class="pre">rr(:,:,:)</span></code>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="kt"><span class="pre">complex</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">alpha</span></span></span><br /></dt>
<dd><p>Coefficient for matrix multiplication.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="kt"><span class="pre">complex</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">beta</span></span></span><br /></dt>
<dd><p>Coefficient for matrix multiplication.</p>
</dd></dl>

</dd></dl>

<dl class="c type">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">struct</span> <span class="pre">spral_ssmfe_options</span></span></dt>
<dd><p>Options that control the algorithm.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.abs_tol_lambda">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">abs_tol_lambda</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.abs_tol_lambda" title="Link to this definition"></a><br /></dt>
<dd><p>Absolute tolerance for estimated
eigenvalue convergence test, see <a class="reference internal" href="#method"><span class="std std-ref">method section</span></a>.
Negative values are treated as the default.
Default is <cite>0.0</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.abs_tol_residual">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">abs_tol_residual</span></span></span><br /></dt>
<dd><p>Absolute tolerance for residual
convergence test, see <a class="reference internal" href="#method"><span class="std std-ref">method section</span></a>. Negative values are
treated as the default.
Default is <cite>0.0</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.max_iterations">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">max_iterations</span></span></span><br /></dt>
<dd><p>Maximum number of iterations.
Default is <cite>100</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.rel_tol_lambda">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rel_tol_lambda</span></span></span><br /></dt>
<dd><p>Relative tolerance for estimated
eigenvalue error convergence test, see <a class="reference internal" href="#method"><span class="std std-ref">method section</span></a>.
Negative values are treated as the default.
Default is <cite>0.0</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.rel_tol_residual">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rel_tol_residual</span></span></span><br /></dt>
<dd><p>Relative tolerance for residual
convergence test, see <a class="reference internal" href="#method"><span class="std std-ref">method section</span></a>. If both
<cite>abs_tol_residual</cite> and <cite>rel_tol_residual</cite> are 0.0, then the
residual norms are not taken into consideration by the convergence
test. Negative values are treated as the
default.
Default is <cite>0.0</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.tol_x">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tol_x</span></span></span><br /></dt>
<dd><p>Tolerance for estimated eigenvector error
convergence test, see <a class="reference internal" href="#method"><span class="std std-ref">method section</span></a>.
If tol_x is set to <cite>0.0</cite>, the eigenvector error is not estimated. If
a negative value is assigned, the tolerance is set to
<cite>sqrt(DBL_EPSILON)</cite>.
Default is <cite>-1.0</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.print_level">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">print_level</span></span></span><br /></dt>
<dd><p>Amount of printing. Possible values are:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>&lt;0</p></td>
<td><p>no printing</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>error and warning messages only</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>the type (standard or generalized) and the size of the problem,
the number of eigenpairs requested, the error tolerances and the
size of the subspace are printed before the iterations start</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>as above but, for each eigenpair tested for convergence, the
iteration number, the index of the eigenpair, the eigenvalue,
whether it has converged, the residual norm, and the error
estimates are also printed</p></td>
</tr>
<tr class="row-odd"><td><p>&gt;2</p></td>
<td><p>as 1 but with all eigenvalues, whether converged, residual norms
and eigenvalue/eigenvector error estimates printed on each
iteration.</p></td>
</tr>
</tbody>
</table>
<p>Note that for eigenpairs that are far from convergence, ‘rough’ error
estimates are printed (the estimates that are actually used by the
stopping criteria, see Section [ssmfe:method], only become available on
the last few iterations).</p>
<p>Default is <cite>0</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.unit_error">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unit_error</span></span></span><br /></dt>
<dd><p>Fortran unit number for error messages. Printing
suppressed if negative.
Default is <cite>6</cite> (stdout).</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.unit_diagnostic">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unit_diagnostic</span></span></span><br /></dt>
<dd><p>Fortran unit number for diagnostic messages.
Printing suppressed if negative.
Default is <cite>6</cite> (stdout).</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.unit_warning">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unit_warning</span></span></span><br /></dt>
<dd><p>Fortran unit number for warning messages.
Printing suppressed if negative.
Default is <cite>6</cite> (stdout).</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.err_est">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">err_est</span></span></span><br /></dt>
<dd><p>Error estimation scheme, one of:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>1</p></td>
<td><p>Residual error bounds: modified Davis-Kahan estimate for
eigenvector error and Lehmann bounds for eigenvale error
(see method section).</p></td>
</tr>
<tr class="row-even"><td><p>2 (default)</p></td>
<td><p>Convergence curve-based estimate.</p></td>
</tr>
</tbody>
</table>
<p>Default is <cite>2</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.extra_left">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">extra_left</span></span></span><br /></dt>
<dd><p>Number of extra approximate eigenvectors
corresponding to leftmost eigenvalues used to enhance convergence.
Default is <cite>0</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.extra_right">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">extra_right</span></span></span><br /></dt>
<dd><p>Number of extra approximate eigenvectors
corresponding to rightmost eigenvalues used to enhance convergence.
Default is <cite>0</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.left_gap">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">left_gap</span></span></span><br /></dt>
<dd><p>Minimal acceptable distance between last
computed left eigenvalue and rest of spectrum.
For <a class="reference internal" href="#c.spral_ssmfe_expert_standard_double" title="spral_ssmfe_expert_standard_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_ssmfe_expert_standard_double()</span></code></a> and
<a class="reference internal" href="#c.spral_ssmfe_expert_generalized_double" title="spral_ssmfe_expert_generalized_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_ssmfe_expert_generalized_double()</span></code></a> the
last computed left eigenvalue is the rightmost of those computed.
For other routines it is the leftmost.
If set to a negative value <span class="math notranslate nohighlight">\(\delta\)</span>, the minimal distance is taken
as <span class="math notranslate nohighlight">\(|\delta|\)</span> times the average distance between the computed
eigenvalues. Note that for this option to have any effect, the value of
<cite>mep</cite> must be larger than <cite>left+right</cite>.
See <a class="reference internal" href="#method"><span class="std std-ref">method section</span></a> for further explanation.
Default is <cite>0</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.max_left">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">max_left</span></span></span><br /></dt>
<dd><p>Number of eigenvalues to left of
<span class="math notranslate nohighlight">\(\sigma\)</span>, or a negative value if not known.
Default is <cite>-1</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.max_right">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">max_right</span></span></span><br /></dt>
<dd><p>Number of eigenvalues to right of
<span class="math notranslate nohighlight">\(\sigma\)</span>, or a negative value if not known.
Default is <cite>-1</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.minAprod">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">minAprod</span></span></span><br /></dt>
<dd><p>If true, minimize number of
multiplications with <span class="math notranslate nohighlight">\(A\)</span> by requiring 2 additional blocks of memory
for the workspace <code class="docutils literal notranslate"><span class="pre">W[:][:][:]</span></code>. Must be true for calls to
<a class="reference internal" href="#c.spral_ssmfe_expert_standard_shift_double" title="spral_ssmfe_expert_standard_shift_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_ssmfe_expert_standard_shift_double()</span></code></a>,
<a class="reference internal" href="#c.spral_ssmfe_expert_generalized_shift_double" title="spral_ssmfe_expert_generalized_shift_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_ssmfe_expert_generalized_shift_double()</span></code></a>,
and <a class="reference internal" href="#c.spral_ssmfe_expert_buckling_double" title="spral_ssmfe_expert_buckling_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">spral_ssmfe_expert_buckling_double()</span></code></a>.
Default is <cite>true</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.minBprod">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">minBprod</span></span></span><br /></dt>
<dd><p>If true, minimize number of
multiplications with <span class="math notranslate nohighlight">\(B\)</span> by requiring 2 additional blocks of memory
for the workspace <code class="docutils literal notranslate"><span class="pre">W[:][:][:]</span></code>.
Default is <cite>true</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.right_gap">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">right_gap</span></span></span><br /></dt>
<dd><p>As <code class="xref c c-member docutils literal notranslate"><span class="pre">options.left_gap</span></code>, but for
right eigenvalues.
Default is <cite>0.0</cite>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.user_x">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">user_x</span></span></span><br /></dt>
<dd><p>Number of eigenvectors for which an initial
guess is supplied in <cite>x[:][:]</cite> on the first call. Such eigenvectors must
be lineraly independent.
Default is <cite>0</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="c type">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">struct</span> <span class="pre">spral_ssmfe_inform</span></span></dt>
<dd><p>Information on progress of the algorithm.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.converged">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">converged</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">mep</span></span><span class="p"><span class="pre">]</span></span><br /></dt>
<dd><p>Convergence status.</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">converged[j]&gt;0</span></code>, the eigenpair <cite>(lambda(j), X(j))</cite> converged
on iteration <cite>converged[j]</cite>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">converged[j]=0</span></code>, the eigenpair <cite>(lambda(j), X(j))</cite> is still
converging.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">converged[j]&lt;0</span></code>, the eigenpair <cite>(lambda(j), X(j))</cite> stagnated
at iteration <cite>-converged[j]</cite>.</p></li>
</ul>
<p>This component is allocated by the routine.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="sig-name descname"><span class="pre">double</span> <span class="pre">err_lambda[mep]:</span></span></dt>
<dd><p>Estimated eigenvalue errors for
converged and stagnated eigenvalues.
This component is allocated by the routine.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.err_x">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">err_x</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">mep</span></span><span class="p"><span class="pre">]</span></span><br /></dt>
<dd><p>Estimated eigenvector errors for
converged and stagnated eigenvectors.
This component is allocated by the routine.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.flag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flag</span></span></span><br /></dt>
<dd><p>Return status of algorithm. See table below.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.iteration">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iteration</span></span></span><br /></dt>
<dd><p>Number of iterations.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.left">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">left</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.left" title="Link to this definition"></a><br /></dt>
<dd><p>Number of converged left eigenvalues.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.next_left">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">next_left</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.next_left" title="Link to this definition"></a><br /></dt>
<dd><p>Upon completion, next left eigenvalue in spectrum
(see <cite>options.left_gap</cite>).</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.next_right">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">next_right</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.next_right" title="Link to this definition"></a><br /></dt>
<dd><p>Upon completion, next right eigenvalue in spectrum
(see <cite>options.right_gap</cite>).</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.residual_norms">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">residual_norms</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">mep</span></span><span class="p"><span class="pre">]</span></span><br /></dt>
<dd><p>Euclidean norms of residuals
for <cite>(lambda[:], X[:])</cite> on return with <code class="docutils literal notranslate"><span class="pre">rci.job=5</span></code>.
This component is allocated by the routine.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.non_converged">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">non_converged</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.non_converged" title="Link to this definition"></a><br /></dt>
<dd><p>Number of non-converged eigenpairs.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.right">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">right</span></span></span><a class="headerlink" href="#c.PhonyNameDueToError.right" title="Link to this definition"></a><br /></dt>
<dd><p>Number of converged right eigenvalues.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PhonyNameDueToError.stat">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">stat</span></span></span><br /></dt>
<dd><p>Fortran allocation status in event of failure.</p>
</dd></dl>

<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>inform.flag</cite></p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-1</p></td>
<td><p>rci.job is out-of-range.</p></td>
</tr>
<tr class="row-odd"><td><p>-2</p></td>
<td><p>m is out-of-range.</p></td>
</tr>
<tr class="row-even"><td><p>-3</p></td>
<td><p>options.err_est is out-of-range.</p></td>
</tr>
<tr class="row-odd"><td><p>-4</p></td>
<td><p>options.minAprod is incompatible with selected routine.</p></td>
</tr>
<tr class="row-even"><td><p>-5</p></td>
<td><p>options.extra_left or options.extra_right is out-of-range.</p></td>
</tr>
<tr class="row-odd"><td><p>-6</p></td>
<td><p>options.min_gap is out-of-range.</p></td>
</tr>
<tr class="row-even"><td><p>-11</p></td>
<td><p>left is out-of-range.</p></td>
</tr>
<tr class="row-odd"><td><p>-12</p></td>
<td><p>right is out-of-range.</p></td>
</tr>
<tr class="row-even"><td><p>-13</p></td>
<td><p>mep is less than the number of desired eigenpairs.</p></td>
</tr>
<tr class="row-odd"><td><p>-100</p></td>
<td><p>Not enough memory; <cite>inform.stat</cite> contains the value of the
Fortran stat parameter.</p></td>
</tr>
<tr class="row-even"><td><p>-200</p></td>
<td><p><span class="math notranslate nohighlight">\(B\)</span> is not positive definite or <cite>user_x&gt;0</cite> and
linearly dependent initial guesses were supplied.</p></td>
</tr>
<tr class="row-odd"><td><p>+1</p></td>
<td><p>The iterations have been terminated because no further
improvement in accuracy is possible (this may happen if
<span class="math notranslate nohighlight">\(B\)</span> or the preconditioner is not positive definite,
or if the components of the residual vectors are so small
that the round-off errors make them essentially random).
The value of <cite>inform.non_converged</cite> is set to the number
of non-converged eigenpairs.</p></td>
</tr>
<tr class="row-even"><td><p>+2</p></td>
<td><p>The maximum number of iterations <cite>max_iterations</cite> has been
exceeded. The value of <cite>inform.non_converged</cite> is set to
the number of non-converged eigenpairs.</p></td>
</tr>
<tr class="row-odd"><td><p>+3</p></td>
<td><p>The solver had run out of storage space for the converged
eigenpairs before the gap in the spectrum required by
<cite>options.left_gap</cite> and/or <cite>options.right_gap</cite> was reached.
The value of <cite>inform.non_converged</cite> is set to the number
of non-converged eigenpairs.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>
<section id="examples">
<span id="example"></span><h2>Examples<a class="headerlink" href="#examples" title="Link to this heading"></a></h2>
<section id="preconditioning-example">
<h3>Preconditioning example<a class="headerlink" href="#preconditioning-example" title="Link to this heading"></a></h3>
<p>The following code computes the 5 leftmost eigenpairs of the matrix
<span class="math notranslate nohighlight">\(A\)</span> of order 100 that approximates the two-dimensional Laplacian
operator on a 20-by-20 grid. One forward and one backward Gauss-Seidel
update are used for preconditioning, which halves the number of
iterations compared with solving the same problem without
preconditioning. The header <cite>laplace2d.h</cite>
(examples/C/ssmfe/laplace2d.h) supplies the subroutine
<cite>apply_laplacian()</cite> that multiplies a block of vectors by <span class="math notranslate nohighlight">\(A\)</span>, and
the subroutine <cite>apply_gauss_seidel_step()</cite> that computes <span class="math notranslate nohighlight">\(y = T x\)</span>
for a block of vectors <span class="math notranslate nohighlight">\(x\)</span> by applying one forward
and one backward update of the Gauss-Seidel method to the system
<span class="math notranslate nohighlight">\(A y = x\)</span>.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/* examples/C/ssmfe/precond_expert.c */</span>
<span class="cm">/* Laplacian on a square grid (using SPRAL_SSMFE_EXPERT routines) */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spral.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cblas.h&gt;</span>

<span class="cm">/* Header that implements Laplacian and preconditioners */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;laplace2d.h&quot;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ngrid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w">          </span><span class="cm">/* grid points along each side */</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">ngrid</span><span class="o">*</span><span class="n">ngrid</span><span class="p">;</span><span class="w"> </span><span class="cm">/* problem size */</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nep</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">           </span><span class="cm">/* eigenpairs wanted */</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">           </span><span class="cm">/* dimension of the iterated subspace */</span>

<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SPRAL_RANDOM_INITIAL_SEED</span><span class="p">;</span><span class="w"> </span><span class="cm">/* PRNG state */</span>

<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ind</span><span class="p">));</span><span class="w">          </span><span class="cm">/* permutation index */</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">lambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lambda</span><span class="p">));</span><span class="w"> </span><span class="cm">/* eigenvalues */</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">X</span><span class="p">)[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">X</span><span class="p">));</span><span class="w">       </span><span class="cm">/* eigenvectors */</span>
<span class="w">   </span><span class="cm">/* Work arrays */</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">rr</span><span class="p">)[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rr</span><span class="p">));</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="mi">6</span><span class="p">][</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">));</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">U</span><span class="p">)[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">U</span><span class="p">));</span>

<span class="w">   </span><span class="cm">/* Derived types */</span>
<span class="w">   </span><span class="k">struct</span><span class="w"> </span><span class="nc">spral_ssmfe_rcid</span><span class="w"> </span><span class="n">rci</span><span class="p">;</span><span class="w">            </span><span class="cm">/* reverse communication data */</span>
<span class="w">   </span><span class="k">struct</span><span class="w"> </span><span class="nc">spral_ssmfe_options</span><span class="w"> </span><span class="n">options</span><span class="p">;</span><span class="w">     </span><span class="cm">/* options */</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">keep</span><span class="p">;</span><span class="w">                             </span><span class="cm">/* private data */</span>
<span class="w">   </span><span class="k">struct</span><span class="w"> </span><span class="nc">spral_ssmfe_inform</span><span class="w"> </span><span class="n">inform</span><span class="p">;</span><span class="w">       </span><span class="cm">/* information */</span>

<span class="w">   </span><span class="cm">/* Initialize options to default values */</span>
<span class="w">   </span><span class="n">spral_ssmfe_default_options</span><span class="p">(</span><span class="o">&amp;</span><span class="n">options</span><span class="p">);</span>
<span class="w">   </span><span class="cm">/* gap between the last converged eigenvalue and the rest of the spectrum</span>
<span class="cm">    * must be at least 0.1 times average gap between computed eigenvalues */</span>
<span class="w">   </span><span class="n">options</span><span class="p">.</span><span class="n">left_gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-0.1</span><span class="p">;</span>
<span class="w">   </span><span class="cm">/* block size is small, convergence may be slow, allow more iterations */</span>
<span class="w">   </span><span class="n">options</span><span class="p">.</span><span class="n">max_iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span>

<span class="w">   </span><span class="cm">/* Initialize W to lin indep vectors by randomizing */</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spral_random_real</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>

<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">ncon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">   </span><span class="cm">/* number of converged eigenpairs */</span>
<span class="w">   </span><span class="n">rci</span><span class="p">.</span><span class="n">job</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">keep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">   </span><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* reverse communication loop */</span>
<span class="w">      </span><span class="n">spral_ssmfe_expert_standard_double</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rci</span><span class="p">,</span><span class="w"> </span><span class="n">nep</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">lambda</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rr</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
<span class="w">         </span><span class="n">ind</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">keep</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">options</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">inform</span><span class="p">);</span>
<span class="w">      </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">job</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">         </span><span class="n">apply_laplacian</span><span class="p">(</span>
<span class="w">            </span><span class="n">ngrid</span><span class="p">,</span><span class="w"> </span><span class="n">ngrid</span><span class="p">,</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="w">            </span><span class="p">);</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span>
<span class="w">         </span><span class="n">apply_gauss_seidel_step</span><span class="w"> </span><span class="p">(</span>
<span class="w">            </span><span class="n">ngrid</span><span class="p">,</span><span class="w"> </span><span class="n">ngrid</span><span class="p">,</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="w">            </span><span class="p">);</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">5</span><span class="p">:</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span>
<span class="w">         </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">&lt;</span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">           </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ncon</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">           </span><span class="n">cblas_dcopy</span><span class="p">(</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="o">+</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">X</span><span class="p">)[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">         </span><span class="n">ncon</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">;</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">11</span><span class="p">:</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">               </span><span class="n">cblas_dcopy</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">               </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">--</span><span class="p">)</span>
<span class="w">                  </span><span class="n">cblas_dcopy</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="o">+</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="o">+</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">         </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">               </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="o">*</span><span class="n">U</span><span class="p">)[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">ind</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">i</span><span class="p">];</span>
<span class="w">               </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">U</span><span class="p">)[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
<span class="w">               </span><span class="k">if</span><span class="p">(</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="o">*</span><span class="n">U</span><span class="p">)[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">ind</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">i</span><span class="p">];</span>
<span class="w">                  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">U</span><span class="p">)[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
<span class="w">               </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">12</span><span class="p">:</span>
<span class="w">         </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="o">*</span><span class="n">rr</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">k</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">i</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">             </span><span class="n">cblas_ddot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">13</span><span class="p">:</span>
<span class="w">         </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">               </span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cblas_dnrm2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">               </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">                  </span><span class="n">cblas_dscal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">               </span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">cblas_ddot</span><span class="p">(</span>
<span class="w">                  </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">                  </span><span class="p">));</span>
<span class="w">               </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                  </span><span class="n">cblas_dscal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">                  </span><span class="n">cblas_dscal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">               </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">                     </span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">               </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">14</span><span class="p">:</span>
<span class="w">         </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">           </span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="o">*</span><span class="n">rr</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">k</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">i</span><span class="o">+</span><span class="n">i</span><span class="p">];</span>
<span class="w">           </span><span class="n">cblas_daxpy</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">15</span><span class="p">:</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">ny</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="n">cblas_dgemm</span><span class="p">(</span>
<span class="w">               </span><span class="n">CblasColMajor</span><span class="p">,</span><span class="w"> </span><span class="n">CblasTrans</span><span class="p">,</span><span class="w"> </span><span class="n">CblasNoTrans</span><span class="p">,</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">ny</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span>
<span class="w">               </span><span class="n">rci</span><span class="p">.</span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">,</span>
<span class="w">               </span><span class="n">rci</span><span class="p">.</span><span class="n">beta</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rr</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">k</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">j</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">m</span>
<span class="w">               </span><span class="p">);</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">16</span><span class="p">:</span><span class="w"> </span><span class="c1">// Fall through to 17</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">17</span><span class="p">:</span>
<span class="w">         </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">ny</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span>
<span class="w">         </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">job</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">beta</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span>
<span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="o">+</span><span class="n">rci</span><span class="p">.</span><span class="n">ny</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">               </span><span class="n">cblas_dscal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">beta</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">         </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">job</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">cblas_dgemm</span><span class="p">(</span>
<span class="w">               </span><span class="n">CblasColMajor</span><span class="p">,</span><span class="w"> </span><span class="n">CblasNoTrans</span><span class="p">,</span><span class="w"> </span><span class="n">CblasNoTrans</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">ny</span><span class="p">,</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">,</span>
<span class="w">               </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rr</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">k</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">j</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">,</span>
<span class="w">               </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>
<span class="w">               </span><span class="p">);</span>
<span class="w">            </span><span class="n">cblas_dcopy</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">rci</span><span class="p">.</span><span class="n">ny</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">         </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">cblas_dgemm</span><span class="p">(</span>
<span class="w">               </span><span class="n">CblasColMajor</span><span class="p">,</span><span class="w"> </span><span class="n">CblasNoTrans</span><span class="p">,</span><span class="w"> </span><span class="n">CblasNoTrans</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">ny</span><span class="p">,</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">,</span>
<span class="w">               </span><span class="n">rci</span><span class="p">.</span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">rr</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">k</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">j</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">i</span><span class="p">],</span>
<span class="w">               </span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">beta</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>
<span class="w">               </span><span class="p">);</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">21</span><span class="p">:</span><span class="w"> </span><span class="c1">// Fall through to 22</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">22</span><span class="p">:</span>
<span class="w">         </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">ncon</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">cblas_dgemm</span><span class="p">(</span>
<span class="w">               </span><span class="n">CblasColMajor</span><span class="p">,</span><span class="w"> </span><span class="n">CblasTrans</span><span class="p">,</span><span class="w"> </span><span class="n">CblasNoTrans</span><span class="p">,</span><span class="w"> </span><span class="n">ncon</span><span class="p">,</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span>
<span class="w">               </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">X</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">ky</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jy</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">U</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>
<span class="w">               </span><span class="p">);</span>
<span class="w">            </span><span class="n">cblas_dgemm</span><span class="p">(</span>
<span class="w">               </span><span class="n">CblasColMajor</span><span class="p">,</span><span class="w"> </span><span class="n">CblasNoTrans</span><span class="p">,</span><span class="w"> </span><span class="n">CblasNoTrans</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ncon</span><span class="p">,</span>
<span class="w">               </span><span class="mf">-1.0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">X</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">U</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="n">rci</span><span class="p">.</span><span class="n">kx</span><span class="p">][</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>
<span class="w">               </span><span class="p">);</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">999</span><span class="p">:</span>
<span class="w">         </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">               </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">rci</span><span class="p">.</span><span class="n">jx</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">               </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="o">*</span><span class="n">W</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spral_random_real</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">default</span><span class="o">:</span>
<span class="w">         </span><span class="k">goto</span><span class="w"> </span><span class="n">finished</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">}</span>
<span class="nl">finished</span><span class="p">:</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">inform</span><span class="p">.</span><span class="n">flag</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;inform.flag = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">inform</span><span class="p">.</span><span class="n">flag</span><span class="p">);</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%3d eigenpairs converged in %d iterations</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ncon</span><span class="p">,</span><span class="w"> </span><span class="n">inform</span><span class="p">.</span><span class="n">iteration</span><span class="p">);</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">ncon</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; lambda[%1d] = %13.7e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">lambda</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">   </span><span class="n">spral_ssmfe_expert_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">keep</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">inform</span><span class="p">);</span>
<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">ind</span><span class="p">);</span>
<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">lambda</span><span class="p">);</span>
<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">rr</span><span class="p">);</span>
<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">W</span><span class="p">);</span>
<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>

<span class="w">   </span><span class="cm">/* Success */</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This code produces the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">6</span> <span class="n">eigenpairs</span> <span class="n">converged</span> <span class="ow">in</span> <span class="mi">129</span> <span class="n">iterations</span>
<span class="k">lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.4676695e-02</span>
<span class="k">lambda</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.1119274e-01</span>
<span class="k">lambda</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.1119274e-01</span>
<span class="k">lambda</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.7770878e-01</span>
<span class="k">lambda</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.2040061e-01</span>
<span class="k">lambda</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.2040061e-01</span>
</pre></div>
</div>
<p>Note that the code computed one extra eigenpair because of the
insufficient gap between the 5th and 6th eigenvalues.</p>
</section>
</section>
<section id="method">
<span id="id1"></span><h2>Method<a class="headerlink" href="#method" title="Link to this heading"></a></h2>
<section id="the-algorithm">
<h3>The algorithm<a class="headerlink" href="#the-algorithm" title="Link to this heading"></a></h3>
<p>The solver procedures of <code class="xref f f-mod docutils literal notranslate"><span class="pre">spral_ssmfe_expert</span></code> are interfaces to solver
procedures of <code class="xref f f-mod docutils literal notranslate"><span class="pre">spral_ssmfe_core</span></code>, which implement a block iterative
algorithm based on the Jacobi-conjugate preconditioned gradients method
<a class="footnote-reference brackets" href="#id6" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#id7" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>. Further information on the algorithm used by
<code class="xref f f-mod docutils literal notranslate"><span class="pre">spral_ssmfe_expert</span></code> can be found in the specification document for
<code class="xref f f-mod docutils literal notranslate"><span class="pre">spral_ssmfe_core</span></code> and in <a class="footnote-reference brackets" href="#id5" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="stopping-criteria">
<h3>Stopping criteria<a class="headerlink" href="#stopping-criteria" title="Link to this heading"></a></h3>
<p>An approximate eigenpair <span class="math notranslate nohighlight">\(\{x,\lambda\}\)</span> is considered to have
converged if the following three conditions are all satisfied:</p>
<ol class="arabic simple">
<li><p>if <cite>options.abs_tol_lambda</cite> and <cite>options.rel_tol_lambda</cite> are not both
equal to zero, then the estimated error in the approximate eigenvalue
must be less than or equal to
<span class="math notranslate nohighlight">\(\max(\mathrm{options\.abs\_tol\_lambda}, \delta*\mathrm{options\.rel\_tol\_lambda})\)</span>,
where <span class="math notranslate nohighlight">\(\delta\)</span> is the estimated average distance between
eigenvalues.</p></li>
<li><p>if <cite>options.tol_x</cite> is not zero, then the estimated sine of the angle
between the approximate eigenvector and the invariant subspace
corresponding to the eigenvalue approximated by <span class="math notranslate nohighlight">\(\lambda\)</span> must
be less than or equal to <cite>options.tol_x</cite>.</p></li>
<li><p>if <cite>options.abs_tol_residual</cite> and <cite>options.rel_tol_residual</cite> are not
both equal to zero, then the Euclidean norm of the residual,
<span class="math notranslate nohighlight">\(\|A x - \lambda B x\|_2\)</span>, must be less than or equal to
<span class="math notranslate nohighlight">\(\max(\mathrm{options\.abs\_tol\_residual}, \mathrm{options\.rel\_tol\_residual}*\|\lambda B x\|_2)\)</span>.</p></li>
</ol>
<p>The extra eigenpairs are not checked for convergence, as their role is
purely auxiliary.</p>
</section>
<section id="improving-eigenvector-accuracy">
<h3>Improving eigenvector accuracy<a class="headerlink" href="#improving-eigenvector-accuracy" title="Link to this heading"></a></h3>
<p>If the gap between the last computed eigenvalue and the rest of the
spectrum is small, then the accuracy of the corresponding eigenvector
may be very low. To prevent this from happening, the user should set the
eigenpairs storage size mep to a value that is larger than the number of
desired eigenpairs, and set the options <cite>options.left_gap</cite> and
<cite>options.right_gap</cite> to non-zero values <span class="math notranslate nohighlight">\(\delta_l\)</span> and
<span class="math notranslate nohighlight">\(\delta_r\)</span>. These values determine the size of the minimal
acceptable gaps between the computed eigenvalues and the rest of the
spectrum, <span class="math notranslate nohighlight">\(\delta_l\)</span> referring to either leftmost eigenvalues (for
<code class="xref f f-subr docutils literal notranslate"><span class="pre">ssmfe_standard()</span></code> and <code class="xref f f-subr docutils literal notranslate"><span class="pre">ssmfe_generalized()</span></code> only) or those
to the left of the shift <cite>sigma</cite>, and <span class="math notranslate nohighlight">\(\delta_r\)</span> to those to the right of
the shift <cite>sigma</cite>. Positive values of <span class="math notranslate nohighlight">\(\delta_l\)</span> and <span class="math notranslate nohighlight">\(\delta_r\)</span> set
the gap explicitly, and negative values require the gap to be not less than
their absolute value times the average distance between the computed
eigenvalues. A recommended value of <span class="math notranslate nohighlight">\(\delta_l\)</span> and
<span class="math notranslate nohighlight">\(\delta_r\)</span> is <span class="math notranslate nohighlight">\(-0.1\)</span>. The value of <cite>mep</cite> has little effect on
the speed of computation, hence it might be set to any reasonably large
value. The larger the value of <cite>mep</cite>, the larger the size of an eigenvalue
cluster for which accurate eigenvectors can be computed, notably: to
safeguard against clusters of size up to <span class="math notranslate nohighlight">\(k\)</span>, it is sufficient to
set mep to the number of desired eigenpairs plus <span class="math notranslate nohighlight">\(k - 1\)</span>.</p>
</section>
<section id="the-use-of-shifted-matrix-factorization">
<h3>The use of shifted matrix factorization<a class="headerlink" href="#the-use-of-shifted-matrix-factorization" title="Link to this heading"></a></h3>
<p>When using the solver procedures that employ the shift-and-invert
technique, it is very important to ensure that the numbers of desired
eigenvalues each side of the shift do not exceed the actual numbers of
these eigenvalues, as the eigenpairs ‘approximating’ non-existing
eigenpairs of the problem will not converge. It is therefore strongly
recommended that the user employs a linear system solver that performs
the <span class="math notranslate nohighlight">\(LDL^T\)</span> factorization of the shifted system, e.g. <cite>HSL_MA97</cite> or
<cite>SPRAL_SSIDS</cite>. The <span class="math notranslate nohighlight">\(LDL^T\)</span> factorization of the matrix
<span class="math notranslate nohighlight">\(A - \sigma B\)</span> consists in finding a lower triangular matrix <span class="math notranslate nohighlight">\(L\)</span>, a
block-diagonal matrix <span class="math notranslate nohighlight">\(D\)</span> with <span class="math notranslate nohighlight">\(1\times 1\)</span> and
<span class="math notranslate nohighlight">\(2\times 2\)</span> blocks on the diagonal and a permutation matrix
<span class="math notranslate nohighlight">\(P\)</span> such that <span class="math notranslate nohighlight">\(P^T(A - \sigma B)P = L D L^T\)</span>. By the inertia
theorem, the number of eigenvalues to the left and right from the shift
<span class="math notranslate nohighlight">\(\sigma\)</span> is equal to the number of negative and positive
eigenvalues of <span class="math notranslate nohighlight">\(D\)</span>, which allows quick computation of the
eigenvalue numbers each side of the shift.</p>
</section>
<section id="error-estimation">
<h3>Error estimation<a class="headerlink" href="#error-estimation" title="Link to this heading"></a></h3>
<section id="standard-problem">
<h4>Standard problem<a class="headerlink" href="#standard-problem" title="Link to this heading"></a></h4>
<p>If <code class="docutils literal notranslate"><span class="pre">options.err_est=1</span></code>, the error estimates for the eigenvalues are
based on the eigenvalues of a matrix of the form</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{L.mx}
\hat A = \tilde\Lambda_k - S_k^T S_k,\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(\tilde\Lambda_k\)</span> is a diagonal matrix with the <span class="math notranslate nohighlight">\(k-1\)</span>
leftmost Ritz values <span class="math notranslate nohighlight">\(\tilde\lambda_j\)</span> on the diagonal, and the
columns of <span class="math notranslate nohighlight">\(S_k\)</span> are the respective residual vectors
<span class="math notranslate nohighlight">\(r_j = A \tilde x_j - \tilde\lambda_j \tilde x_j\)</span> divided by
<span class="math notranslate nohighlight">\(\sqrt{\lambda_k - \tilde\lambda_j}\)</span>. If <span class="math notranslate nohighlight">\(k\)</span> is such that
<span class="math notranslate nohighlight">\(\tilde\lambda_{k-1} &lt; \lambda_k\)</span>, then the eigenvalues of
<span class="math notranslate nohighlight">\(\hat A\)</span> are the left-hand side bounds for eigenvalues
<span class="math notranslate nohighlight">\(\lambda_i\)</span>, and thus the difference
<span class="math notranslate nohighlight">\(\tilde\lambda_j - \hat\lambda_j\)</span> estimates the eigenvalue error
<span class="math notranslate nohighlight">\(\tilde\lambda_j - \lambda_j\)</span>. The unknown <span class="math notranslate nohighlight">\(\lambda_k\)</span> is
replaced by <span class="math notranslate nohighlight">\(\tilde\lambda_k\)</span>, and select the maximal
<span class="math notranslate nohighlight">\(k \le m\)</span> for which the distance between
<span class="math notranslate nohighlight">\(\tilde\lambda_{k-1}\)</span> and <span class="math notranslate nohighlight">\(\tilde\lambda_k\)</span> exceeds the sum
of the absolute error tolerance for eigenvalues and the Frobenius norm
of the matrix formed by the residuals <span class="math notranslate nohighlight">\(r_j, j = 1, \ldots, k-1\)</span>.
If <span class="math notranslate nohighlight">\(\tilde\lambda_j - \hat\lambda_j\)</span> is close to the machine
accuracy, it may be too polluted by round-off errors to rely upon. In
such case, we use instead</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\tilde\lambda_j - \lambda_j \le \delta_j \approx
\frac{\|r_j\|^2}{\tilde\lambda_k - \lambda_j}.\end{aligned}\]</div>
<p>The eigenvector errors are estimated based on the Davis-Kahan
inequality:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\min_{x \in \mathcal{X}_{k-1}}
\sin\{\tilde x_j; x\} \le
\frac{\|r_j\|}{\lambda_k - \tilde\lambda_j} \approx
\frac{\|r_j\|}{\tilde\lambda_k - \tilde\lambda_j},\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{X}_{k-1}\)</span> is the invariant subspace corresponding
to <span class="math notranslate nohighlight">\(k-1\)</span> leftmost eigenvalues.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">options.err_est=2</span></code> the errors are estimated based on the
eigenvalue decrements history, which produces an estimate for the
average eigenvalue error reduction per iteration, which in turn yields
error estimates for both eigenvalues and eigenvectors. Unlike the
residual estimates mentioned in this section, such ‘kinematic’ error
estimates are not guaranteed to be upper bounds for the actual errors.
However, the numerical tests have demonstrated that kinematic error
estimates are significantly more accurate, i.e. closer to the actual
error, than the residual-based estimates. Furthermore, they
straightforwardly apply to the generalized case as well.</p>
</section>
<section id="generalized-problem">
<h4>Generalized problem<a class="headerlink" href="#generalized-problem" title="Link to this heading"></a></h4>
<p>In the case of the generalized eigenvalue problem solved by iterations
with preconditioning, all of the residual norms in the previous section
must be replaced with <span class="math notranslate nohighlight">\(\|\cdot\|_{B^{-1}}\)</span>-norm of the residual
<span class="math notranslate nohighlight">\(r_j = A \tilde x_j - \tilde\lambda_j B \tilde x_j\)</span>
(<span class="math notranslate nohighlight">\(\|r_j\|_{B^{-1}}^2 = r_j^* B^{-1} r_j\)</span>) or its upper estimate,
e.g. <span class="math notranslate nohighlight">\(\beta_1^{-1/2}\|\cdot\|\)</span>, where <span class="math notranslate nohighlight">\(\beta_1\)</span> is the
smallest eigenvalue of <span class="math notranslate nohighlight">\(B\)</span>. Hence, if <span class="math notranslate nohighlight">\(\beta_1\)</span> is known,
then the error tolerances for eigenvalues and eigenvectors must be
multiplied by <span class="math notranslate nohighlight">\(\beta_1\)</span> and <span class="math notranslate nohighlight">\(\sqrt{\beta_1}\)</span> respectively.
If no estimate for <span class="math notranslate nohighlight">\(\|\cdot\|_{B^{-1}}\)</span>-norm is available, then
the use of non-zero residual tolerances and
<code class="docutils literal notranslate"><span class="pre">options.err_est=1</span></code> is not recommended. In the case of
problems solved by iterations with shift-and-invert and the problem ,
the residuals are computed as
<span class="math notranslate nohighlight">\(r_j = T B \tilde x_j - \tilde \lambda_j \tilde x_j\)</span> where
<span class="math notranslate nohighlight">\(T = (A - \sigma B)^{-1}\)</span> for and <span class="math notranslate nohighlight">\(T = (B - \sigma A)^{-1}\)</span>
for , and <span class="math notranslate nohighlight">\(B\)</span>-norms of <span class="math notranslate nohighlight">\(r_j\)</span> are used, so that Lehmann
matrix becomes <span class="math notranslate nohighlight">\(\hat A = \tilde\Lambda_k - S_k^T B\ S_k\)</span>. 0 Note
that the residual estimates may considerably overestimate the actual
error of direct iterations because of the use of the Euclidean norm of
the residual, which is too strong a norm for it when <span class="math notranslate nohighlight">\(A\)</span> is the
discretization of a differential operator.</p>
</section>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Link to this heading"></a></h3>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">1</a><span class="fn-bracket">]</span></span>
<p>E. E. Ovtchinnikov and J. Reid (2010).
<em>A preconditioned block conjugate gradient algorithm for computing extreme
eigenpairs of symmetric and Hermitian problems</em>.
Technical Report RAL-TR-2010-19.</p>
</aside>
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>E. E. Ovtchinnikov (2008).
<em>Jacobi correction equation, line search and conjugate gradients in
Hermitian eigenvalue computation I: Computing an extreme eigenvalue</em>.
SIAM J. Numer. Anal., 46:2567–2592.</p>
</aside>
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>E. E. Ovtchinnikov (2008).
<em>Jacobi correction equation, line search and conjugate gradients in
Hermitian eigenvalue computation II: Computing several extreme eigenvalues</em>.
SIAM J. Numer. Anal., 46:2593–2619.</p>
</aside>
</aside>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ssmfe.html" class="btn btn-neutral float-left" title="SSMFE - Sparse Symmetric Matrix-Free Eigensolver" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ssmfe_core.html" class="btn btn-neutral float-right" title="SSMFE_CORE - Sparse Symmetric Matrix-Free Eigensolver (Core Algorithm)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Computational Mathematics Group, STFC Rutherford Appleton Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>