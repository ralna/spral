\packagename{SSIDS}
\version{1.0.0}
\versiondate{17 March 2014}
\purpose{
   This package solves one or more sets of $n\times n$
   sparse {\bf symmetric} equations  ${AX = B}$ using a multifrontal method on an
   \textbf{NVIDIA GPU}.
   The following cases are covered:
   \begin{enumerate}
   \item $A$ is {\bf indefinite}.
   \texttt{SSIDS} computes the sparse factorization
   $$
      A =  PLD(PL)^T
   $$
   where $P$ is a permutation matrix, $L$ is unit lower triangular,
   and $D$ is block diagonal with blocks of size $1 \times 1 $
   and $2 \times 2$.
   \item $A$ is {\bf positive definite}.
   \texttt{SSIDS} computes the {\bf sparse Cholesky factorization}
   $$
      A =  PL(PL)^T
   $$
   where $P$ is a permutation matrix and $L$ is lower triangular.
   \textit{However, as \texttt{SSIDS} is designed primarily for indefinite
   systems, this may be slower than a dedicated Cholesky solver.}
   \end{enumerate}

   \texttt{SSIDS} returns bit-compatible results.

   An option exists to scale the matrix. In this case, the factorization of
   the scaled matrix  $ {\overline{A} = S A S}$ is computed,
   where ${S}$ is a diagonal scaling matrix.
}

\title{Sparse Symmetric Indefinite Direct Solver}
\author{
   Jonathan Hogg (STFC Rutherford Appleton Laboratory) \\
   Evgueni Ovtchinnikov (STFC Rutherford Appleton Laboratory) \\
   Jennifer Scott (STFC Rutherford Appleton Laboratory)
}
\pkglang{Fortran}
\spralmaketitle
\thispagestyle{firststyle}

\section*{Major version history}
\begin{description}
\item[2014-03-17 Version 1.0.0] Initial release
\end{description}

%%%%%%%%%%%%%%%%%%%%%% installation %%%%%%%%%%%%%%%%%%%%%%

\section{Installation}
Please see the SPRAL install documentation. In particular note that:
\begin{itemize}
   \item A CUDA compiler (\texttt{nvcc}) is required.
   \item A METIS library is required.
   \item A BLAS library is required (in addition to CUBLAS).
   %\item For multi-GPU or multi-stream work, OpenMP must be enabled.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%% how to use %%%%%%%%%%%%%%%%%%%%%%%%

\section{Usage overview}

\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement \\ \\
\indent\hspace{8mm}{\tt use spral\_ssids} \\

\medskip

\noindent
The following procedures are available to the user:
\begin{itemize}
\item {\tt ssids\_analyse()} accepts the matrix data in compressed
sparse column format and optionally checks it for duplicates and  out-of-range entries.
The user may supply an elimination order; otherwise
one is generated. Using this elimination order,
{\tt ssids\_analyse()} analyses the sparsity pattern of
the matrix and prepares the data structures for the factorization.

 \item {\tt ssids\_analyse\_coord()} is an alternative to
{\tt ssids\_analyse()} that may be used if the user has
the matrix data in coordinate
format. Again, the user may supply an elimination order; otherwise
one is generated. {\tt ssids\_analyse\_coord()}
checks the matrix data  for duplicates and  out-of-range entries,
stores
it in compressed sparse column format and then proceeds
in the same way as {\tt ssids\_analyse()}.

\item {\tt ssids\_factor()} uses the data structures
set up by {\tt ssids\_analyse()} to compute a sparse
factorization. More than one call to  {\tt ssids\_factor()}
may follow a call to {\tt ssids\_analyse()} (allowing more than
one matrix with the same sparsity pattern but different
numerical values to be factorized without multiple calls to
{\tt ssids\_analyse()}).
An option exists to scale the matrix.

\item {\tt ssids\_solve()} uses the computed factors generated
by  {\tt ssids\_factor()}
to solve systems ${AX= B}$
for one or more right-hand sides $B$.
Multiple calls to {\tt ssids\_solve()} may follow a call to
{\tt ssids\_factor()}.
An option is available to perform a partial solution.

\item {\tt ssids\_free()} should be called after all other calls
are complete for a problem (including after an error
return that does not allow the computation
to continue). It frees memory referenced by components of
the derived types. This routine also allows created by either
{\tt ssids\_analyse() or ssids\_factorize()} to be freed separately.
\end{itemize}

\noindent
In addition, the following routines may be called:
\begin{itemize}
\item {\tt ssids\_enquire\_posdef()} may be called
in the  positive-definite case to obtain the pivots used.
\item {\tt ssids\_enquire\_indef()} may be called
in the indefinite case to obtain the pivot sequence used by the factorization
and the entries of  ${D}^{-1}$.
\item {\tt ssids\_alter()} may be called in the indefinite case to alter
the entries of ${D}^{-1}$.
Note that this means that  $PLD(PL)^T$ is no longer
a factorization of $A$.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Derived types}

For each problem, the user must employ the derived types defined by the
package to declare scalars of the types
{\tt ssids\_options}, {\tt ssids\_inform}, {\tt ssids\_akeep}, and {\tt ssids\_fkeep}.
The following pseudo-code illustrates this.
\begin{verbatim}
      use spral_ssids
      ...
      type (ssids_options) :: options
      type (ssids_inform) :: inform
      type (ssids_akeep) :: akeep
      type (ssids_fkeep) :: fkeep
      ...
\end{verbatim}
The components of {\tt ssids\_options} and {\tt ssids\_inform} are explained
in Sections~\ref{ssids:type:options} and \ref{ssids:type:inform}.
The components of {\tt ssids\_akeep} and {\tt ssids\_fkeep} are used to pass
data between the subroutines of the package and must not be altered by the user.

\subsection{Achieving bit-compatibility}
Care has been taken to ensure bit-compatibility is achieved using this solver.
That is, consecutive runs with the same data on the same machine  produces exactly
the same solution.

\subsection{Optional arguments}

We use square brackets {\tt [ ]} to indicate {\it optional} arguments.
In each
call, optional arguments follow the argument {\tt inform}.  Since we
reserve the right to add additional optional arguments in future
releases of the code, {\bf we strongly recommend that all optional
arguments be called by keyword, not by position}.

\subsection{Integer, real and package types}

{\tt INTEGER} denotes default {\tt INTEGER} and
{\tt INTEGER(long)} denotes {\tt INTEGER(kind=selected\_int\_kind(18))}.

\noindent
{\tt REAL} denotes double precision real.
We also use the term {\bf package type} to mean the same.

\subsection{Data formats} \label{ssids:dataformats}

\begin{figure}
   \caption{ \label{ssids:format eg}
      Data format example matrix
   }
   $$
      \left( \begin{array}{ccccc}
         1.1 & 2.2 &     & 3.3 &     \\
         2.2 &     & 4.4 &     &     \\
             & 4.4 & 5.5 &     & 6.6 \\
         3.3 &     &     & 7.7 & 8.8 \\
             &     & 6.6 & 8.8 & 9.9
      \end{array} \right)
   $$
\end{figure}

\subsubsection{Compressed Sparse Column (CSC) Format} \label{ssids:cscformat}
This standard data format consists of the following data:
\begin{verbatim}
   integer                   :: n      ! size of matrix
   integer, size(n+1)        :: ptr    ! column pointers
   integer, size(ptr(n+1)-1) :: row    ! row indices
   real,    size(ptr(n+1)-1) :: val    ! numerical values
\end{verbatim}
Non-zero matrix entries are ordered by increasing column index and stored in
the arrays \texttt{row(:)} and \texttt{val(:)} such that \texttt{row(k)} holds
the row number and \texttt{val(k)} holds the value of the \texttt{k}-th entry.
The \texttt{ptr(:)} array stores column pointers such that \texttt{ptr(i)} is
the position in \texttt{row(:)} and \texttt{val(:)} of
the first entry in the \texttt{i}-th column, and \texttt{ptr(n+1)} is one more
than the total number of entries.
Entries that are zero, including those on the diagonal, need not be specified.

If this format is used, \texttt{SSIDS} requires only the lower triangular entries of $A$, and there 
should be no duplicate entries. If the \texttt{check}
argument to
\texttt{ssids\_analyse()} is \texttt{.true.}, out-of-range entries (including
those in the upper triangle) will be discarded and any duplicates will be
summed.

To illustrate the CSC format, the following arrays describe the matrix shown in
Figure~\ref{ssids:format eg}.
\begin{verbatim}
   n = 5
   ptr(1:6) = (/ 1,             4,   5,        7,        9,    10 /)
   row(1:9) = (/ 1,   2,   4,   3,   3,   5,   4,   5,   5 /)
   val(1:9) = (/ 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9 /)
\end{verbatim}

\subsubsection{Coordinate Format} \label{ssids:coordformat}
This standard data format consists of the following data:
\begin{verbatim}
   integer           :: n     ! size of matrix
   integer           :: ne    ! number of non-zero entries
   integer, size(ne) :: row   ! row indices
   integer, size(ne) :: col   ! column indices
   real,    size(ne) :: val   ! numerical values
\end{verbatim}
The arrays should be set such that the \texttt{k}-th entry is in row
\texttt{row(k)} and column \texttt{col(k)} with value \texttt{val(k)}.
Entries that are zero, including those on the diagonal, need not be specified.

If this format is used,
\texttt{SSIDS} requires that each entry of $A$ should be present \textbf{only} in the
lower \textit{or} upper triangular part. Entries present in both will be summed, as
will any duplicate entries. Out-of-range entries are ignored.

To illustrate the coordinate format, the following arrays describe the matrix shown in
Figure~\ref{ssids:format eg}.
\begin{verbatim}
   n = 5
   ne = 9
   row(1:9) = (/ 1,   2,   3,   4,   3,   5,   4,   5,   5 /)
   col(1:9) = (/ 1,   1,   2,   1,   3,   3,   4,   4,   5 /)
   val(1:9) = (/ 1.1, 2.2, 4.4, 3.3, 5.5, 6.6, 7.7, 8.8, 9.9 /)
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\section{Basic Subroutines}

%%%%%%%%% analyse subroutine %%%%%%

\subsection{\texttt{ssids\_analyse()} and \texttt{ssids\_analyse\_coord()}}

\textbf{
   To analyse the sparsity pattern and prepare for the factorization,
   \begin{itemize}
      \item[] for Compressed Sparse Column (CSC) format:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_analyse(check,n,ptr,row,akeep,options,inform[,order,val])
      }
      \item[] for Coordinate format:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_analyse\_coord(n,ne,row,col,akeep,options,inform[,order,val])
      }
   \end{itemize}
}

\noindent
Matrix data should be supplied as described in Section~\ref{ssids:dataformats}. As
the package uses CSC format internally, \texttt{ssids\_analyse()} with checking
disabled provides the most efficient interface.

\noindent
\begin{description}

\item[\texttt{check}] is an \intentin\ scalar of
type  {\tt LOGICAL}. If set to {\tt .true.} the matrix
data is checked for errors and the cleaned matrix
(duplicates are summed and out-of-range entries
discarded) is stored in {\tt akeep}.
Otherwise, for data in CSC format, no checking of the matrix data is carried out
and {\tt ptr(:)} and {\tt row(:)} must be passed unchanged to the factorization routines. 
Checking is always performed when the coordinate format is used.

\item[\texttt{n}{\rm ,} \texttt{ptr(:)}{\rm ,} \texttt{row(:)}] are \intentin\ 
   variables of type {\tt INTEGER} specifying the lower triangular part of $A$
   in CSC format (see Section~\ref{ssids:cscformat}).

\item[\texttt{n}{\rm ,} \texttt{ne}{\rm ,} \texttt{row(:)}{\rm ,} \texttt{col(:)}]
   are \intentin\ variables of type {\tt INTEGER} specifying the lower
   (or upper) triangular part of $A$ in coordinate format (see Section~\ref{ssids:coordformat}).

\item[\texttt{akeep}] is an \intentout\ scalar of type
{\tt ssids\_akeep}. It is used to hold data about the problem being
solved and must be passed unchanged to the other subroutines.

\item[\texttt{options}] is an \intentin\ scalar of type {\tt ssids\_options}.
Its components specify the algorithmic options used by the subroutine, as
explained in Section~\ref{ssids:type:options}.

\item[\texttt{inform}] is an \intentout\ scalar of type
{\tt ssids\_inform}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{ssids:type:inform}.

\item[\texttt{order(:)}] is an optional \intentinout\ array of type
{\tt INTEGER} and size {\tt n}. If {\tt options\%ordering}$=${\tt 0},
{\tt order(:)} must be present and {\tt order(i)} must hold the  position of
variable $i$  in the elimination order. On exit, {\tt order(:)} contains the
elimination order that {\tt ssids\_factor()} will be given (it is passed to these
routines as part of {\tt akeep}); this order may give slightly more fill-in
than the user-supplied order and, in the indefinite case, may be modified by
{\tt ssids\_factor()} to maintain numerical stability. 

\item[\texttt{val(:)}] is an optional \intentin\ array of package type that must
hold the numerical values of the entries of the matrix, as described in
Section~\ref{ssids:dataformats}.
{\tt val(:)} must be present if a matching-based elimination ordering is
required ({\tt options\%ordering$=$2}), and is otherwise ignored.

\end{description}


%%%%%%%%% factorize subroutine %%%%%%
\subsection{\texttt{ssids\_factor()}}
\textbf{To factorize the matrix,
   \vspace*{0.1cm} \\
   \texttt{ \hspace*{0.2cm}
      call ssids\_factor(posdef,val,akeep,fkeep,options,inform[,scale,ptr,row])
   }
}

\begin{description}
\item[\texttt{posdef}] is an \intentin\ scalar of type {\tt LOGICAL} that
must be set to {\tt .true.} if the matrix is positive-definite, and
{\tt .false.} if it is indefinite.

\item[\texttt{val(:)}] is an \intentin\ array of package type that must hold
the numerical values of the entries of the matrix, as described in
Section~\ref{ssids:dataformats}.

\item[\texttt{akeep}]  is an \intentin\ scalar of type
{\tt ssids\_akeep} that must be unchanged since the
call to {\tt ssids\_analyse()} or {\tt ssids\_analyse\_coord()}.

\item[\texttt{fkeep}]  is an \intentinout\ scalar of type
{\tt ssids\_fkeep}. It is used to hold data about the problem being
solved and must be passed unchanged to the other subroutines.

\item[\texttt{options}] is an \intentin\ scalar of type {\tt ssids\_options}.
Its components specify the algorithmic options used by the subroutine, as
explained in Section~\ref{ssids:type:options}.

\item[\texttt{inform}] is an \intentout\ scalar of type
{\tt ssids\_inform}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{ssids:type:inform}.

\item[\texttt{scale(:)}] is an optional \intentinout\ array of type {\tt REAL}
and size {\tt n}. If present and \texttt{options\%scaling=0}, it must contain
the diagonal entries of the scaling matrix ${S}$. On exit, \texttt{scale(i)}
will contain the \texttt{i}-th diagonal entry of the scaling matrix $S$.

\item[\texttt{ptr(:)}] and {\tt row(:)} are optional \intentin\ arrays of
type {\tt INTEGER}. They are only accessed if {\tt ssids\_analyse()} was called
with {\tt check} set to {\tt .false.}.
In this case, they must both be present and  must be unchanged since that call.

\end{description}

%%%%%%%%% solve subroutine %%%%%%
\subsection{\texttt{ssids\_solve()}} \label{ssids:fn:solve}
\textbf{ To solve the linear system $AX=B$, after a call to
   \texttt{ssids\_factor()},
   \begin{itemize}
      \item[] for a single right-hand side:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_solve(x1,akeep,fkeep,options,inform[,job])
      }
      \item[] for one or more right-hand sides:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_solve(nrhs,x,ldx,akeep,fkeep,options,inform[,job])
      }
   \end{itemize}
}

\noindent
Partial solutions may be performed by appropriately setting the optional
parameter {\tt job}.

\begin{description}
\item[\texttt{x1(:)}] is an \intentinout\ array of package type and size
\texttt{n}. It must be set such that \texttt{x1(i)} holds the component of
the right-hand side for variables $i$. On exit, \texttt{x1(i)} holds the
solution for variable $i$.

\item[\texttt{nrhs}] is an \intentin\ scalar of type {\tt INTEGER} that holds
the number of right-hand sides.

\item[\texttt{x(:,:)}] is an \intentinout\ array of package type with extents
\texttt{ldx} and \texttt{nrhs}. It must be set so that \texttt{x(i,j)} holds the
component of the right-hand side for variable $i$ to the $j$-th
system. On exit, \texttt{x(i,j)} holds the solution for variable $i$ to
the $j$-th system.

\item[\texttt{ldx}] is an \intentin\ scalar of type {\tt INTEGER} that must be
   set to the first extent of array \texttt{x(:)}.

\item[\texttt{akeep}]  is an \intentin\ scalar of type {\tt ssids\_akeep} that
must be unchanged since the last call to {\tt ssids\_factor()}.

\item[\texttt{fkeep}]  is an \intentin\ scalar of type {\tt ssids\_fkeep} that
must be unchanged since the last call to {\tt ssids\_factor()}.

\item[\texttt{options}] is an \intentin\ scalar of type {\tt ssids\_options}.
Its components specify the algorithmic options used by the subroutine, as
explained in Section~\ref{ssids:type:options}.

\item[\texttt{inform}] is an \intentout\ scalar of type
{\tt ssids\_inform}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{ssids:type:inform}.

\item[\texttt{job}] is an optional  \intentin\ scalar of
type  {\tt INTEGER}. If absent, ${AX = B}$ is solved.
In the positive-definite case, the Cholesky factorization
that has been computed may be expressed in the form
\[ {SAS} = ({PL})({PL})^T \]
where $P$ is a permutation matrix and $L$ is lower triangular.
In the indefinite case, the factorization
that has been computed may be expressed in the form
\[ {S AS} = ({PL}){D}({PL})^T \]
where $P$ is a permutation matrix, $L$ is unit lower triangular,
and $D$ is block diagonal with blocks of order 1 and 2.
$S$ is a diagonal scaling matrix ($S$ is equal to the identity,
if \texttt{options\%scaling=0} and
{\tt scale} is not present on the last call to {\tt ssids\_factor}()).
A partial solution may be computed by setting {\tt job} to have
one of the following values:
\begin{description}
\item[\texttt{1}] for solving ${PLX} = {SB}$
\item[\texttt{2}] for solving ${DX} = {B}$ (indefinite case only)
\item[\texttt{3}] for solving $({PL})^T{S^{-1}X} = {B}$
\item[\texttt{4}] for solving $D({PL})^T{S^{-1}X} = {B}$ (indefinite case only)
\end{description}

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsection{\texttt{ssids\_free()}}
\textbf{To free memory and resources,
   \begin{itemize}
      \item[] allocated by \texttt{ssids\_analyse()} or \texttt{ssids\_analyse\_coord()}:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_free(akeep,cuda\_error)
      }
      \item[] allocated by \texttt{ssids\_factor()}:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_free(fkeep,cuda\_error)
      }
      \item[] both at once:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_free(akeep,fkeep,cuda\_error)
      }
   \end{itemize}
}
Once all other calls are complete for a problem or after an error
return that does not allow the computation to continue,
a call should be made to free memory and CUDA resources allocated by
\texttt{SSIDS} and associated with the derived data types {\tt akeep} and/or
{\tt fkeep} using calls to \texttt{ssids\_free()}.

\begin{description}

\item[\texttt{akeep}] is an \intentinout\ scalar  of type {\tt ssids\_akeep}
that must be passed unchanged.
On exit, allocatable components will have been deallocated, and CUDA resources
released.

\item[\texttt{fkeep}] is an \intentinout\ scalar  of type {\tt ssids\_fkeep}
that must be passed unchanged.
On exit, allocatable components will have been deallocated, and CUDA resources
released.

\item[\texttt{cuda\_error}] is an \intentout\ scalar of type default integer.
On exit, a non-zero value gives a CUDA error code. This may indicate either
a failure to deallocate GPU memory, or a pre-existing CUDA error condition.
Note that due to the asynchronous nature of GPU execution, the
reported error may have a cause errors external to {\tt SSIDS}.

\end{description}

\section{Advanced subroutines}

%%%%%%% enquire subroutine %%%%%%

\subsection{\texttt{ssids\_enquire\_posdef()}}
\textbf{To obtain the matrix $D$ following a positive-definite factorization,
   \vspace*{0.1cm} \\
   \texttt{ \hspace*{0.2cm}
      call ssids\_enquire\_posdef(akeep,fkeep,options,inform,d)
   }
}

\begin{description}

\item[\texttt{akeep}]  is an \intentin\ scalar of type {\tt ssids\_akeep} that
must be unchanged since the call to {\tt ssids\_factor()}.

\item[\texttt{fkeep}]  is an \intentin\ scalar of type {\tt ssids\_fkeep} that
must be unchanged since the call to {\tt ssids\_factor()}.

\item[\texttt{options}] is an \intentin\ scalar of type {\tt ssids\_options}.
Its components specify the algorithmic options used by the subroutine, as
explained in Section~\ref{ssids:type:options}.

\item[\texttt{inform}] is an \intentout\ scalar of type
{\tt ssids\_inform}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{ssids:type:inform}.

\item[\texttt{d(:)}] is an  \intentout\ array of type {\tt  REAL} and
size {\tt n}. The $i$-th diagonal entry of $D$ will be placed in {\tt d(i)}.

\end{description}
%%%%%%% enquire subroutine %%%%%%

\subsection{\texttt{ssids\_enquire\_indef()}}
\textbf{To obtain the matrix $D^{-1}$ and/or the pivot order following an
   indefinite factorization,
   \vspace*{0.1cm} \\
   \texttt{ \hspace*{0.2cm}
     call ssids\_enquire\_indef(akeep,fkeep,options,inform[,piv\_order,d])
   }
}

\begin{description}

\item[\texttt{akeep}]  is an \intentin\ scalar of type {\tt ssids\_akeep} that
must be unchanged since the call to {\tt ssids\_factor()}.

\item[\texttt{fkeep}]  is an \intentin\ scalar of type {\tt ssids\_fkeep} that
must be unchanged since the call to {\tt ssids\_factor()}.

\item[\texttt{options}] is an \intentin\ scalar of type {\tt ssids\_options}.
Its components specify the algorithmic options used by the subroutine, as
explained in Section~\ref{ssids:type:options}.

\item[\texttt{inform}] is an \intentout\ scalar of type
{\tt ssids\_inform}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{ssids:type:inform}.

\item[\texttt{piv\_order(:)}] is an optional \intentout\ array of type
{\tt INTEGER} and size {\tt n}. If present, on exit
$|\,\texttt{piv\_order(i)}|$ gives the position of variable $i$ in the pivot
order. The sign will be positive if $i$ is a $1\times1$ pivot, and negative
if $i$ is part of a $2 \times 2$ pivot.

\item[\texttt{d(:,:)}] is an optional \intentout\ array of package type with
extents {\tt 2} and {\tt n}.
If present, on exit diagonal entries of ${D}^{-1}$ will be placed
in {\tt d(1,i)}, $i = 1,2,\ldots,n$,
the off-diagonal entries  of ${D}^{-1}$ will be placed in
{\tt d(2,i)}, $i = 1,2,\ldots,n-1$, and
{\tt d(2,n)} will be set to zero.

\end{description}


%%%%%%% alter subroutine %%%%%%

\subsection{\texttt{ssids\_alter()}}
\textbf{To alter ${\bf D}^{-1}$ following an indefinite factorization,
   \vspace*{0.1cm} \\
   \texttt{ \hspace*{0.2cm}
      call ssids\_alter(d,akeep,fkeep,options,inform)
   }
}

\vspace{0.3cm}
\noindent
Note that this routine is not compatabile with the option \texttt{options.presolve}$=$\texttt{1}.

\begin{description}

\item[\texttt{d(:,:)}] is an \intentin\ array of package type with
extents {\tt 2}  and {\tt n}. The diagonal entries
of ${D}^{-1}$ will be altered to {\tt d(1,i)}, $i = 1,2,\ldots,n$,
and the off-diagonal entries will be altered to
{\tt d(2,i)}, $i = 1,2,\ldots,n-1$ (and $PLD(PL)^T$ will no longer be
a factorization of $A$).

\item[\texttt{akeep}]  is an \intentin\ scalar of type {\tt ssids\_akeep} that
must be unchanged since the call to {\tt ssids\_factor()}.

\item[\texttt{fkeep}]  is an \intentinout\ scalar of type {\tt ssids\_fkeep}
that must be unchanged since the call to {\tt ssids\_factor()}.

\end{description}

%%%%%%%%%%% options type %%%%%%%%%%%

\section{Derived types}
\subsection{\texttt{ssids\_options}}
\label{ssids:type:options}

The derived data type {\tt ssids\_options} is used to specify the options used
within \texttt{SSIDS}. The components, that are automatically
given default values in the definition of the type, are: \\

%%%%%%%%%%%%
\subsubsection*{Printing options}

\begin{description}

\item[\texttt{print\_level}] is a scalar of type  {\tt INTEGER}
that is used to control the level of printing. The different levels are:
\begin{description}
\item{\tt $<$ 0 } No printing.
\item{\tt = 0 } Error and warning messages only.
\item{\tt = 1 } As 0, plus basic diagnostic printing.
\item{\tt $>$ 1 } As 1, plus some additional diagnostic printing.
\end{description}
The default is {\tt print\_level$=$\tt 0}.

\item[\texttt{unit\_diagnostics}] is a scalar  of type
{\tt INTEGER} that holds the
unit number for diagnostic printing. Printing is suppressed if
{\tt unit\_diagnostics$<0$}.
The default is {\tt unit\_diagnostics$=$6}.

\item[\texttt{unit\_error}] is a scalar of type  {\tt INTEGER} that holds the
unit number for error messages.
Printing of error messages
is suppressed if {\tt unit\_error$<$0}.
The default is {\tt unit\_error$=$6}.

\item[\texttt{unit\_warning}] is a scalar  of type  {\tt INTEGER} that holds the
unit number for warning messages.
Printing of warning messages is suppressed if {\tt unit\_warning$<$0}.
The default is {\tt unit\_warning$=$6}.

\end{description}



%%%%%%%%%%%%
\subsubsection*{Options used by {\tt ssids\_analyse()} and
{\tt ssids\_analyse\_coord()}}

\begin{description}

\item[\texttt{ordering}] is a scalar of
type  {\tt INTEGER}. If set to {\tt 0}, the user
must supply an elimination order in {\tt order(:)}; otherwise
an elimination order will be computed by {\tt ssids\_analyse()}
or {\tt ssids\_analyse\_coord()}.
The options are:
\begin{description}
\item{} {\tt 0} User-supplied ordering is used.
\item{} {\tt 1} METIS ordering with default settings is used.
\item{} {\tt 2} A matching-based elimination ordering is computed (the Hungarian
algorithm is used to identify large off-diagonal entries. A restricted METIS
ordering is then used that forces these on to the subdiagonal).
This option should only be chosen for indefinite systems.
A scaling is also computed that may be used in {\tt ssids\_factor()}
(see {\tt options\%scaling} below).
\end{description}
The default is {\tt ordering}$=${\tt 1}.
{\bf Restriction:} {\tt ordering}$=${\tt 0}, {\tt 1}, {\tt 2}.

\item[\texttt{nemin}] is a scalar of type  {\tt INTEGER} that controls
node amalgamation. Two neighbours in the elimination tree are merged
if they both involve fewer than {\tt nemin} eliminations.
The default is {\tt nemin$=$8}.
The default is used if {\tt nemin$<$1}.
\end{description}

%%%%%%%%%%%%
\subsubsection*{Options used by {\tt ssids\_factor()}}
\begin{description}
\item[\texttt{scaling}] is a scalar of type default {\tt INTEGER} that controls
   the use of scaling. The available
options are:
\begin{description}
   \item[\texttt{ $\le$ 0 }] No scaling (if \texttt{scale(:)} is not present),
      or user-supplied scaling (if \texttt{scale(:)} is present).
   \item[\texttt{ $=$ 1 }] Compute a scaling using a weighted bipartite matching
      via the Hungarian Algorithm (\texttt{MC64} algorithm).
   \item[\texttt{ $=$ 2 }] Compute a scaling using a weighted bipartite matching
      via the Auction Algorithm (may be lower quality than that computed using 
      the Hungarian Algorithm, but can be considerably faster).
   \item[\texttt{ $=$ 3 }] A matching-based ordering has been generated during the
      analyse phase using {\tt options\%ordering $=$ 2}. Use the
      scaling generated as a side-effect of this process. The scaling will be
      the same as that generated with {\tt options\%scaling $=$ 1} if the matrix
      values have not changed. This option will generate an error if a
      matching-based ordering was not used.
   \item[\texttt{ $\ge$ 4 }] Compute a scaling using the norm-equilibration
      algorithm of Ruiz.
\end{description}
The default is {\tt scaling}$=${\tt 0}.

\end{description}

%%%%%%%%%%%%
\subsubsection*{Options used by {\tt ssids\_factor()} with
{\tt posdef}$ =${\tt .false.}  ($A$ indefinite)}

\begin{description}
\item[\texttt{action}] is a scalar of type default {\tt LOGICAL}.
If the matrix is found to be singular (has rank less than the number of
non-empty rows), the computation continues after issuing a warning if
{\tt action} has the value {\tt .true.} or
terminates with an error if it has the value {\tt .false.}.
The default is {\tt action}$=${\tt .true.}.

%\item[\texttt{small}] is a scalar of type {\tt REAL}.
%Any pivot whose modulus is less than {\tt small} is treated as zero.
%The default is {\tt small}$ = {\tt 10^{-20}}$.

\item[\texttt{u}] is a scalar of type {\tt REAL} that holds the relative pivot
tolerance $u$.
The default is {\tt u}$=${\tt 0.01}.
Values outside the range $[0,0.5]$ are treated as the closest value in that range.

\end{description}

%%%%%%%%%%%%
\subsubsection*{Options used by {\tt ssids\_factor()} and {\tt ssids\_solve()}}

\begin{description}
\item[\texttt{use\_gpu\_solve}] is a scalar of type {\tt LOGICAL} that controls
   whether to use the CPU or GPU for the \texttt{ssids\_solve()}. If
   \texttt{.true.}, the GPU is used, but some more advanced features are not
   available (see the description of the \texttt{job} parameter in
   Section~\ref{ssids:fn:solve}).
   Setting \texttt{use\_gpu\_solve}$=${\tt .false.} is only compatible with
   \texttt{options\%presolve}$=${\tt 0}.
   The default value is \texttt{use\_gpu\_solve}$=$\texttt{.true.}.
\item[\texttt{presolve}] is a scalar of type {\tt INTEGER} that controls the
   amount of extra work performed during factorization to accelerate the solve.
   It can take the following values:
   \begin{description}
      \item[\texttt{0}] Minimal work is performed during {\tt ssids\_factor()}
         to prepare for the solve.
      \item[\texttt{1}] The explicit inverse of the
         \texttt{nelim}$\times$\texttt{nelim} block in each supernode is
         precalculated during {\tt ssids\_factor()} (where \texttt{nelim} is
         the number of variables eliminated at that supernode). As the matrix
         $L$ is overwritten, the routine {\tt ssids\_alter()} cannot be used.
         This option is not compatible with {\tt options\%use\_gpu\_solve}$=$\texttt{.false.}.
   \end{description}
   The default option is \texttt{presolve}$=$\texttt{0}.
\end{description}

%%%%%%%%%%% inform type %%%%%%%%%%%

\subsection{\texttt{ssids\_inform}}
\label{ssids:type:inform}
The derived data type {\tt ssids\_inform}
is used to hold parameters that give information about the progress and needs
of the algorithm. The components of {\tt ssids\_inform}
(in alphabetical order) are:

\begin{description}

\item[\texttt{flag}] is a scalar of type  {\tt INTEGER}
that gives the exit status of the algorithm (details in Section \ref{ssids:errors}).

\item[\texttt{matrix\_dup}] is a scalar  of type  {\tt INTEGER}.
On exit from {\tt ssids\_analyse()}
with {\tt check} set to {\tt .true.} or from \\
{\tt ssids\_analyse\_coord()}, it holds the
number of duplicate entries that were found and summed.

\item[\texttt{matrix\_missing\_diag}] is a scalar of type {\tt INTEGER}.
On exit from {\tt ssids\_analyse()} with {\tt check} set to {\tt .true.},
or from {\tt ssids\_analyse\_coord()}, it holds the number of diagonal
entries without an explicitly provided value.

\item[\texttt{matrix\_outrange}] is a scalar  of type  {\tt INTEGER}.
On exit from {\tt ssids\_analyse()}
with {\tt check} set to {\tt .true.} or from \\
{\tt ssids\_analyse\_coord()}, it holds the
number of out-of-range entries that were   found and discarded.

\item[\texttt{matrix\_rank}] is scalar of type  {\tt INTEGER}. On exit from
{\tt ssids\_analyse()} and {\tt ssids\_analyse\_coord()}, it holds
the structural rank of $A$, if available (otherwise, it is set to {\tt n}).
On exit from
{\tt ssids\_factor()}, it holds the computed rank of
the factorized matrix.

\item[\texttt{maxdepth}] is a scalar of type  {\tt INTEGER}. On exit from
{\tt ssids\_analyse()} or {\tt ssids\_analyse\_coord()}, it holds the maximum depth of the assembly tree.

\item[\texttt{maxfront}] is a scalar of type  {\tt INTEGER}. On exit from
{\tt ssids\_analyse()} or {\tt ssids\_analyse\_coord()}, it holds the maximum front size
in the positive-definite case (or in the indefinite case with
the same pivot sequence). On exit from
{\tt ssids\_factor()}, it holds the maximum front size.

\item[\texttt{num\_delay}] is scalar of type  {\tt INTEGER}. On exit from
{\tt ssids\_factor()}, it holds the
number of eliminations that were
delayed, that is, the total number of fully-summed
variables that were passed to the father node because
of stability considerations. If a variable is passed
further up the tree, it will be counted again.

\item[\texttt{num\_factor}] is scalar of type {\tt INTEGER(long)}. On exit from
{\tt ssids\_analyse()}  or {\tt ssids\_analyse\_coord()}, it holds the number of entries that will be in the
factor $L$ in the positive-definite case (or in the indefinite case with
the same pivot sequence). On exit from
{\tt ssids\_factor()},
it holds the actual number of entries in the factor
$L$. In the indefinite case, {\tt 2n} entries of ${D}^{-1}$ are
also held.

\item[\texttt{num\_flops}] is scalar of type {\tt INTEGER(long)}. On exit from
{\tt ssids\_analyse()}  or {\tt ssids\_analyse\_coord()}, it holds the number of
floating-point operations that
will be needed to perform the factorization
in the positive-definite case (or in the indefinite case  with
the same pivot sequence).  On exit from {\tt ssids\_factor()}, it holds the
number of floating-point operations performed.

\item[\texttt{num\_neg}] is a scalar  of type  {\tt INTEGER}.
On exit from {\tt ssids\_factor()}, it holds
the number of negative eigenvalues of the matrix $D$.


\item[\texttt{num\_sup}] is a scalar of type  {\tt INTEGER}.
On exit from {\tt ssids\_analyse()}  or {\tt ssids\_analyse\_coord()}, it holds
the number of supernodes in the problem.

\item[\texttt{num\_two}] is scalar of type  {\tt INTEGER}.
On exit from
{\tt ssids\_factor()}, it holds the number
of $2 \times 2$ pivots used by the factorization, that is,
the number of $2 \times 2$ blocks in $D$.

\item[\texttt{stat}] is a scalar of type  {\tt INTEGER}.
In the event of an allocation or deallocation error, it
holds the Fortran {\tt stat} parameter if it is available
(and is set to {\tt 0} otherwise).

\item[\texttt{cublas\_error}] is a scalar of type {\tt INTEGER}.
In the event of an error return from the CUBLAS library, it
holds the error code returned (and is {\tt 0} otherwise).

\item[\texttt{cuda\_error}] is a scalar of type {\tt INTEGER}.
In the event of a CUDA error, it holds the error code returned (and is {\tt 0}
otherwise). Note that due to the asynchronous nature of GPU execution, the
reported error may have a cause errors external to {\tt SSIDS}.

\end{description}


%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\section{Return codes} \label{ssids:errors}

A successful return from a subroutine in the package is indicated by
{\tt inform\%flag} having the value zero.
A negative value is associated with an error message that by default will
be output on unit {\tt options\%unit\_error}.

Possible negative values are:

\begin{description}
\item{$-$1} An error has been made in the sequence of calls (this includes
            calling a subroutine after an error that cannot be recovered from).
\item{$-$2} Returned by {\tt ssids\_analyse()} and {\tt ssids\_analyse\_coord()}
            if {\tt n$<$0}. Also returned by {\tt ssids\_analyse\_coord()} if
            {\tt ne$<$1}.
\item{$-$3} Returned by {\tt ssids\_analyse()} if there is an error in
            {\tt ptr(:)}.
\item{$-$4} Returned by {\tt ssids\_analyse()} if all the variable indices in
            one or more columns  are out-of-range. Also returned by
            {\tt ssids\_analyse\_coord()} if all entries are out-of-range.
\item{$-$5} Returned by {\tt ssids\_factor()} if
            {\tt posdef}$=${\tt .false.} and
            {\tt options\%action = .false.} when the matrix is found to be
            singular. The user may reset the matrix values in {\tt val(:)}
            and recall {\tt ssids\_factor()}.
\item{$-$6} Returned by {\tt ssids\_factor()} if
            {\tt posdef}$=${\tt .true.} and the matrix is found to
            be not positive definite. This may be because the Hungarian scaling
            determined that the matrix was structurally singular. The user may
            reset the matrix values in {\tt val(:)} and recall
            {\tt ssids\_factor()}.
\item{$-$7} Returned by {\tt ssids\_factor()} if {\tt ssids\_analyse()} was
            called with {\tt check} set to {\tt .false.} but {\tt ptr(:)}
            and/or {\tt row(:)} is not present.
\item{$-$8} Returned by {\tt ssids\_analyse()}  and
            {\tt ssids\_analyse\_coord()} if {\tt options\%ordering} is
            out-of-range, or {\tt options\%ordering}$=${\tt 0} and the user
            has either failed to provide an elimination order or an error has
            been found in the user-supplied elimination order (as supplied in
            {\tt order(:)}).
\item{$-$9} Returned by {\tt ssids\_analyse()} and
            {\tt ssids\_analyse\_coord()} if {\tt options\%ordering}$=${\tt 2},
            but {\tt val(:)} was not supplied.
\item{$-$10} Returned by {\tt ssids\_solve()} if there is an error in the size
            of array {\tt x(:,:)} (that is, {\tt ldx$<$n} or {\tt nrhs$<$1}).
            The user may reset {\tt ldx} and/or {\tt nrhs} and recall
            {\tt ssids\_solve()}.
\item{$-$11} Returned by {\tt ssids\_solve()} if {\tt job} is out-of-range.
            The user may reset {\tt job} and recall {\tt ssids\_solve()}.
\item{$-$12} Returned by {\tt spral\_ssids\_solve()} and 
            {\tt spral\_ssids\_alter()} if the selected combination of
            {\tt options\%use\_gpu\_solve} and {\tt options\%presolve} are not 
            compatible with the requested operation.
\item{$-$13} Returned by {\tt ssids\_enquire\_posdef()} if
            {\tt posdef}$=${\tt .false.} on the last call
            to {\tt ssids\_factor()}.
\item{$-$14} Returned by {\tt ssids\_enquire\_indef()} if
            {\tt posdef}$=${\tt .true.} on the last call to
            {\tt ssids\_factor()}.
\item{$-$15} Returned by {\tt ssids\_factor()} if {\tt options\%scaling$=$3}
            but a matching based ordering was not used during the call to
            {\tt ssids\_analyse()} or {\tt ssids\_analyse\_coord()} (i.e. was
            called with
            {\tt options\%ordering}$\ne${\tt 2}).
\item{$-$50} Allocation error. If available, the {\tt stat}
            parameter is returned in {\tt inform\%stat}.
\item{$-$51} CUDA error. The CUDA error return value is returned in
            {\tt inform\%cuda\_error}.
\item{$-$52} CUBLAS error. The CUBLAS error return value is returned in
            {\tt inform\%cublas\_error}.
\end{description}
A positive value of {\tt inform\%flag}
is used to warn the user that the input matrix data may be faulty or that
the subroutine cannot guarantee the solution obtained.
Possible values are:
\begin{description}
\item{$+$1} Returned by {\tt ssids\_analyse()}
and {\tt ssids\_analyse\_coord()} if out-of-range variable
indices found.
Any such entries are ignored  and the computation continues.
{\tt inform\%matrix\_outrange} is set to the number of such entries.

\item{$+$2} Returned by {\tt ssids\_analyse()} and {\tt ssids\_analyse\_coord()}
if duplicated indices found. Duplicates are recorded and the corresponding
entries are summed. {\tt inform\%matrix\_dup} is set to the number of such entries.

\item{$+$3} Returned by {\tt ssids\_analyse()} and {\tt ssids\_analyse\_coord()} if both
out-of-range and duplicated variable indices found.

\item{$+$4} Returned by {\tt ssids\_analyse()}  and {\tt ssids\_analyse\_coord()}
if  one and more diagonal entries
of $A$ is missing.

\item{$+$5} Returned by {\tt ssids\_analyse()}  and {\tt ssids\_analyse\_coord()}
if  one and more diagonal entries
of $A$ is missing  and
out-of-range and/or duplicated variable indices have been found.

\item{$+$6} Returned by {\tt ssids\_analyse()}  and {\tt ssids\_analyse\_coord()} if
$A$ is found be (structurally) singular. This will overwrite any of the above warnings.

\item{$+$7} Returned by {\tt ssids\_factor()} if {\tt options\%action} is set
to {\tt .true.} and the matrix is found to be (structurally or numerically)
singular.

\item{$+$8} Returned by {\tt ssids\_factor()} if
{\tt options\%ordering}$=${\tt 2} (i.e.
a matching-based ordering was used) but the associated scaling was not (i.e. {\tt options\%scaling}$\ne$
{\tt 3}).

\end{description}

\section{Method} \label{method}

\subsection*{\texttt{ssids\_analyse()} and \texttt{ssids\_analyse\_coord()}}
If {\tt check} is set to {\tt .true.} on the call to {\tt ssids\_analyse()}
or if {\tt ssids\_analyse\_coord()} is called, 
the user-supplied matrix data is checked for errors. The cleaned integer matrix data
(duplicates are summed and out-of-range indices discarded) is stored in
{\tt akeep}.
The use of checking is optional on a call to {\tt ssids\_analyse()} as it
incurs both time and memory overheads. However, it is recommended
since the behaviour of the other routines in the package
is unpredictable if duplicates and/or out-of-range variable indices are entered.

If the user has supplied an elimination order it is checked for errors. Otherwise,
an elimination order is generated by the package. 
The elimination order is used to construct an assembly tree.
On exit from {\tt ssids\_analyse()} (and {\tt ssids\_analyse\_coord()}), 
{\tt order(:)} is set so that {\tt order(i)} holds the position
of variable $i$ in the elimination order. If an ordering was supplied by the user, this
order may differ, but will be equivalent in terms of fill-in.

%If a matching-based elimination order is requested and {\tt scale(:)} is present, on exit,
%{\tt scale(:)} contains scaling factors that are computed as a bi-product of
%the ordering algorithm and these may be passed unchanged to {\tt ssids\_factor()}.

\subsection*{\texttt{ssids\_factor()}}
{\tt ssids\_factor()} optionally computes a scaling and then performs the numerical factorization.
 The user must specify whether or not the matrix is
positive definite. If {\tt posdef} is set to {\tt .true.}, no pivoting
is performed and the computation will terminate with an error if a
non-positive pivot is encountered.

The factorization uses the assembly tree that was set up by the analyse phase.
At each  node,  entries from $A$ and, if it is not a leaf node,
the generated elements and any delayed pivots from its child nodes
must be assembled. Separate kernels handle each of these.


The kernel that performs the assembly from the child nodes considers one parent-child
assembly at a time. Each  generated element from a child is divided into a number of
tiles, and a thread block launched to assemble each tile into a 
dense submatrix using a simple
mapping array to determine the destination row and column of each entry.
Bit-compatibility is achieved by ensuring the child entries are
always assembled in the same order. 

A dense partial factorization of the fully summed columns is then performed. The
fully summed columns are split into a number
of tiles that are each handled by an associated  block. Factorization
proceeds one column of tiles at a time. The pivoting condition is chosen to
ensure that all entries of $L$ have absolute value less than $\texttt{u}^{-1}$.
This limits the growth of the entries of the $D$ factor and ensures that any
solves will be backwards stable. The details are described in [1].

If a pivot candidate does not pass the pivot tests at a node, it is delayed
to its parent node, where further elimination operations may make it acceptable.
Delaying pivots leads to additional fill-in and floating-point
operations beyond that predicted by {\tt ssids\_analyse()}  (and {\tt ssids\_analyse\_coord()}), 
and may result in additional memory allocations being required.
The number of delayed pivots can often be reduced by using appropriate scaling.

At each non-root node, the majority of the floating-point operations  involve the formation
of the generated element. 
This is handled by a single dedicated kernel; again, see [1] for details.

At the end of the factorization, data structures for use in future calls to
\texttt{ssids\_solve()} are prepared. If \texttt{options\%presolve=1}, the
block of $L$ corresponding to the eliminated variables is explicitly inverted
to accelerate future calls to \texttt{ssids\_solve()} at the cost of making
\texttt{ssids\_factor()} slower.

\subsection*{\texttt{ssids\_solve()}}
If \texttt{options\%use\_gpu\_solve}$=$\texttt{.false.}, data is moved to the
CPU if required and the BLAS calls are used to perform a solve using the
assembly tree and factors generated on previous calls.

Otherwise, the solve is conducted on the GPU in a similar fashion. If
\texttt{options\%presolve=0}, custom GPU implementations of \texttt{\_trsv()}
and \texttt{\_gemv()} are used to handle multiple independent operations. If
multiple right-hand sides are to be solved for, the single right-hand side solve is looped over. If \texttt{options\%presolve=1}, \texttt{\_trsv()} can be
replaced by the much more parallel (and hence faster) \texttt{\_gemv()}. In
this case multiple right-hand sides are handled at the same time.

\subsection*{References}
[1] J.D. Hogg, E. Ovtchinnikov and J.A. Scott. (2014).
A sparse symmetric indefinite direct solver for GPU architectures.
RAL Technical Report. RAL-P-2014-0xx, to appear.



%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\section{Example}

Suppose we wish to factorize the matrix
\[ A = \left(
\begin{array}{ccccc}
2. & 1. \\
1. & 4. & 1. & & 1. \\
 & 1. & 3. & 2. \\
& & 2. & 0. &  \\
& 1. & & & 2.
\end{array}
\right)
\]
and then solve for the right-hand side
\[ B = \left(
\begin{array}{c}
4. \\
17. \\
19. \\
6. \\
12.
\end{array}
\right).
\]
The following code may be used.
\verbatiminput{examples/Fortran/ssids.f90}
This produces the following output:
\begin{verbatim}
 Warning from ssids_analyse. Warning flag =   4
 one or more diagonal entries is missing

 The computed solution is:
  1.0000000000E+00  2.0000000000E+00  3.0000000000E+00
  4.0000000000E+00  5.0000000000E+00
 Pivot order:   4    5   -2   -1    3

\end{verbatim}

\begin{funders}
   \funder{epsrc}{Funded by EPSRC grant EP/J010553/1}
\end{funders}
